<!DOCTYPE html><html lang="hu"><head><title>JavaScript Garden</title><meta charset="utf-8"><meta name="description" content="Bevezet√©s a JavaScript bugyraiba, hib√°iba."><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="shortcut icon" href="/JavaScript-Garden/favicon.ico?v=2"><link rel="stylesheet" href="../style/garden.css" media="all"><link rel="stylesheet" href="../style/print.css" media="print"><!--[if lt IE 9]>
<script src="javascript/html5.js"></script>
<![endif]--></head><body><!-- Navigation--><nav id="nav_main"><div><ul><li><a href="/JavaScript-Garden/by" title="JavaScript Garden">by</a></li><li><a href="/JavaScript-Garden/" title="JavaScript Garden">en</a></li><li><a href="/JavaScript-Garden/es" title="Jard√≠n de JavaScript">es</a></li><li><a href="/JavaScript-Garden/fi" title="JavaScript-puutarha">fi</a></li><li><a href="/JavaScript-Garden/fr" title="Le Jardin de JavaScript">fr</a></li><li class="active"><a href="/JavaScript-Garden/hu" title="JavaScript Garden">hu</a></li><li><a href="/JavaScript-Garden/it" title="JavaScript Garden">it</a></li><li><a href="/JavaScript-Garden/ja" title="JavaScript Garden">ja</a></li><li><a href="/JavaScript-Garden/ko" title="JavaScript Garden">ko</a></li><li><a href="/JavaScript-Garden/pl" title="JavaScript Garden">pl</a></li><li><a href="/JavaScript-Garden/ptbr" title="JavaScript Garden">ptbr</a></li><li><a href="/JavaScript-Garden/ru" title="JavaScript –ì–∞—Ä–¥–µ–Ω">ru</a></li><li><a href="/JavaScript-Garden/tr" title="JavaScript Garden">tr</a></li><li><a href="/JavaScript-Garden/zh" title="JavaScript ÁßòÂØÜËä±Âõ≠">zh</a></li><li><a href="/JavaScript-Garden/zhtw" title="JavaScript Garden">zhtw</a></li></ul><a id="top" href="#intro" title="Back to top">#top</a><a id="hide_menu" class="tablet">Hide Menu</a></div><ul><li class="nav_intro"><h1><a href="#intro">Bevezet≈ë</a></h1><ul></ul></li><li class="nav_object"><h1><a href="#object">Objektumok</a></h1><ul><li><a href="#object.general">Objektumok √©s mez≈ëk haszn√°lata</a></li><li><a href="#object.prototype">A Protot√≠pus</a></li><li><a href="#object.hasownproperty"><code>hasOwnProperty</code></a></li><li><a href="#object.forinloop">A <code>for in</code> ciklus</a></li></ul></li><li class="nav_function"><h1><a href="#function">F√ºggv√©nyek</a></h1><ul><li><a href="#function.general">F√ºggv√©ny deklar√°ci√≥k √©s kifejez√©sek</a></li><li><a href="#function.this">A <code>this</code> m√°gikus m≈±k√∂d√©se</a></li><li><a href="#function.closures">Closure-√∂k √©s referenci√°k</a></li><li><a href="#function.arguments">Az <code>arguments</code> objektum</a></li><li><a href="#function.constructors">Konstruktorok</a></li><li><a href="#function.scopes">N√©vterek √©s hat√≥k√∂r√∂k</a></li></ul></li><li class="nav_array"><h1><a href="#array">T√∂mb√∂k</a></h1><ul><li><a href="#array.general">T√∂mb iter√°ci√≥ √©s tulajdons√°gok</a></li><li><a href="#array.constructor">Az <code>Array</code> konstruktor</a></li></ul></li><li class="nav_types"><h1><a href="#types">T√≠pusok</a></h1><ul><li><a href="#types.equality">Egyenl≈ës√©g vizsg√°lat</a></li><li><a href="#types.typeof">A <code>typeof</code> vizsg√°lat</a></li><li><a href="#types.instanceof">Az <code>instanceof</code> oper√°tor</a></li><li><a href="#types.casting">T√≠pus kasztol√°s</a></li></ul></li><li class="nav_core"><h1><a href="#core">L√©nyeg</a></h1><ul><li><a href="#core.eval">Mi√©rt Ne Haszn√°ljuk az <code>eval</code>-t</a></li><li><a href="#core.undefined">Az <code>undefined</code> √©s a <code>null</code></a></li><li><a href="#core.semicolon">Automatic Semicolon Insertion</a></li><li><a href="#core.delete">A <code>delete</code> Oper√°tor</a></li></ul></li><li class="nav_other"><h1><a href="#other">Egy√©b</a></h1><ul><li><a href="#other.timeouts">A var√°zslatos <code>setTimeout</code> √©s <code>setInterval</code></a></li></ul></li></ul></nav><!-- Mobile navigation--><nav id="nav_mobile"><a id="nav_prev_section" href="#">prev section<span class="nav_section_name">section name</span></a><a id="nav_next_section" href="#">next section<span class="nav_section_name">section name</span></a><a id="show_menu">show menu</a></nav><!-- Sections--><section id="intro"><!-- Introduction--><header id="intro.intro"><h1>Bevezet≈ë</h1></header><!-- Articles--><article id="intro.index"><h2>Bevezet≈ë</h2><div><p>A <strong>JavaScript Garden</strong> egy folytonosan n√∂vekv≈ë k√≥dgy≈±jtem√©ny amely a nyelv kih√≠v√°st okoz√≥ r√©szeit hivatott tiszt√°zni. Itt tan√°csokat kaphatsz afel≈ël, hogyan ker√ºld el a leggyakoribb programoz√°si- valamint nyelvi hib√°kat, hogyan √≠rj gyorsabb k√≥dot, √©s mik a legs≈±r≈±bben elk√∂vetett <em>bad practice</em>k amelyekkel egy √°tlagos JavaScript programoz√≥ (nem) mindennapi √∫tj√°n tal√°lkozhat a nyelv megismer√©se k√∂zben. </p>
<p>A JavaScript Gardennek <strong>nem</strong> c√©lja, hogy megtan√≠tsa a JavaScript nyelvet!
Az itt felsorolt t√©m√°k meg√©rt√©s√©hez mindenk√©pp sz√ºks√©ges n√©mi tapasztalat. Ha a nyelv alapjait szeretn√©d elsaj√°t√≠tani, el≈ësz√∂r n√©zd √°t ezt a kiv√°l√≥ <a href="https://developer.mozilla.org/en/JavaScript/Guide">tutorialt</a> a Mozilla Developer Network√∂n.</p>
<h2 id="szerz-k">Szerz≈ëk</h2>
<p>Ez a le√≠r√°s k√©t kiv√°l√≥ <a href="http://stackoverflow.com/">Stack Overflow</a> felhaszn√°l√≥, <a href="http://stackoverflow.com/users/170224/ivo-wetzel">Ivo Wetzel</a> (szerz≈ë) √©s <a href="http://stackoverflow.com/users/313758/yi-jiang">Zhang Yi Jiang</a> (Design) toll√°b√≥l sz√ºletett.</p>
<p>A dokumentumot jelenleg <a href="http://truffles.me.uk">Tim Ruffles</a> gondozza.</p>
<h2 id="hozz-j-rultak-m-g">Hozz√°j√°rultak m√©g</h2>
<ul>
<li><p>T√∫l hossz√∫ lenne itt mindenkit felsorolni, l√°sd a <a href="https://github.com/BonsaiDen/JavaScript-Garden/graphs/contributors">k√∂zrem≈±k√∂d≈ëk list√°j√°t</a>.</p>
</li>
<li><p>A magyar ford√≠t√°s <a href="https://twitter.com/jozsefDevs">jozsefDevs</a> j√≥volt√°b√≥l sz√ºletett.</p>
</li>
</ul>
<h2 id="hosting">Hosting</h2>
<p>A JavaScript Garden a GitHubon van hostolva, de a <a href="http://cramerdev.com/">Cramer Development</a> j√≥volt√°b√≥l
a <a href="http://javascriptgarden.info/">JavaScriptGarden.info</a> c√≠men is el√©rhet≈ë.</p>
<h2 id="licensz">Licensz</h2>
<p>A JavaScript Garden az <a href="https://github.com/BonsaiDen/JavaScript-Garden/blob/next/LICENSE">MIT licensszel</a> van ell√°tva √©s a <a href="https://github.com/BonsaiDen/JavaScript-Garden">GitHubon</a> hostoljuk.
Ha b√°rmilyen hib√°t vagy el√≠r√°st veszel √©szre, k√©rlek <a href="https://github.com/BonsaiDen/JavaScript-Garden/issues">jelezd azt</a>, vagy jav√≠tsd √©s k√ºldj egy pull requestet. Tov√°bb√°, megtal√°lhatsz minket a <a href="http://chat.stackoverflow.com/rooms/17/javascript">JavasScript szob√°ban</a> a Stack Overflow chaten.</p>
</div></article></section><section id="object"><!-- Introduction--><header id="object.intro"><h1>Objektumok</h1></header><!-- Articles--><article id="object.general"><h2>Objektumok √©s mez≈ëk haszn√°lata</h2><div><p>A JavaScriptben minden objektumk√©nt m≈±k√∂dik, a <a href="#core.undefined"><code>null</code></a> √©s az <a href="#core.undefined"><code>undefined</code></a> kiv√©tel√©vel.</p>
<pre><code>false.toString(); // &#39;false&#39;
[1, 2, 3].toString(); // &#39;1,2,3&#39;

function Foo(){}
Foo.bar = 1;
Foo.bar; // 1</code></pre>
<p>Gyakori t√©vhitk√©nt terjed, hogy a JavaScriptben a sz√°mok nem haszn√°lhat√≥ak objektumk√©nt. 
Ez csak l√°tsz√≥lag igaz, mivel a JavaScript a pont ut√°ni r√©szt √∫gy pr√≥b√°lja √©rtelmezni,
mintha lebeg≈ëpontos sz√°mot l√°tna. √çgy hib√°t kaphatunk.  </p>
<pre><code>2.toString(); // SyntaxErrort v√°lt ki</code></pre>
<p>Azonban sz√°mos kifejez√©s l√©tezik megold√°sk√©nt, amelyekkel megker√ºlhet≈ë ez a probl√©ma.</p>
<pre><code>2..toString(); // √≠gy a m√°sodik pont m√°r az objektumra utal
2 .toString(); // fontos a space-t √©szrevenni itt a pont el≈ëtt
(2).toString(); // a 2 √©rt√©kel≈ëdik ki hamarabb</code></pre>
<h3 id="objektumok-mint-adatt-pusok">Objektumok mint adatt√≠pusok</h3>
<p>Az objektumok JavaScriptben <a href="http://en.wikipedia.org/wiki/Hashmap"><em>Hash t√°blak√©nt</em></a> is haszn√°lhat√≥ak, mivel term√©szetszer≈±leg kulcs-√©rt√©k p√°rokat tartalmaznak.</p>
<p>Az objektum liter√°l le√≠r√°s√°val - <code>{}</code> jel√∂l√©ssel - lehet l√©trehozni egy √∫j objektumot. Ez az √∫j objektum az <code>Object.prototype</code>-b√≥l <a href="#object.prototype">sz√°rmazik</a> √©s nincsenek <a href="#object.hasownproperty">saj√°t mez≈ëi</a> defini√°lva.</p>
<pre><code>var foo = {}; // egy √∫j, √ºres objektum

// egy √∫j objektum egy &#39;test&#39; nev≈± mez≈ëvel, aminek 12 az √©rt√©ke
var bar = {test: 12}; </code></pre>
<h3 id="mez-k-el-r-se">Mez≈ëk el√©r√©se</h3>
<p>Egy objektum mez≈ëi k√©tf√©le m√≥don √©rhet≈ëek el, vagy az &#39;objektum.mez≈ën√©v&#39; jel√∂l√©ssel,
(Ford.: amit &quot;dot notationk√©nt&quot; emleget√ºnk) vagy a sz√∂gletes z√°r√≥jelek kirak√°s√°val.</p>
<pre><code>var foo = {name: &#39;macska&#39;}
foo.name; // macska
foo[&#39;name&#39;]; // macska

var get = &#39;name&#39;;
foo[get]; // macska

foo.1234; // SyntaxError
foo[&#39;1234&#39;]; // m≈±k√∂dik</code></pre>
<p>A k√©t jel√∂l√©s majdnem egyen√©rt√©k≈±en haszn√°lhat√≥, kiv√©ve, hogy a sz√∂gletes z√°r√≥jelekkel dinamikusan √°ll√≠thatunk be mez≈ëket √©s olyan neveket is v√°laszthatunk, amik am√∫gy szintaxis hib√°hoz vezetn√©nek (Ford√≠t√≥: mivel a neveket stringbe kell rakni, megadhatunk a JS √°ltal &quot;lefoglalt&quot; kulcsszavakat is mez≈ën√©vk√©nt, hab√°r ennek haszn√°lata er≈ësen ker√ºlend≈ë).</p>
<h3 id="mez-k-t-rl-se">Mez≈ëk t√∂rl√©se</h3>
<p>Egyetlen m√≥don lehet mez≈ët t√∂r√∂lni egy objektumb√≥l, ez pedig a <code>delete</code> oper√°tor
haszn√°lata; a mez≈ë √©rt√©k√©nek <code>undefined</code>-ra vagy <code>null</code>-ra val√≥ √°ll√≠t√°sa csak
mag√°ra az √©rt√©kre van kihat√°ssal, de a kulcs ugyan√∫gy megmarad az objektumban.</p>
<pre><code>var obj = {
    bar: 1,
    foo: 2,
    baz: 3
};
obj.bar = undefined;
obj.foo = null;
delete obj.baz;

for(var i in obj) {
    if (obj.hasOwnProperty(i)) {
        console.log(i, &#39;&#39; + obj[i]);
    }
}</code></pre>
<p>A fenti ciklus a <code>bar undefined</code> √©s a <code>foo null</code> eredm√©nyeket fogja ki√≠rni - 
egyed√ºl a <code>baz</code> mez≈ë ker√ºlt t√∂rl√©sre, √©s emiatt hi√°nyzik is az outputr√≥l.</p>
<h3 id="kulcsok-jel-l-se">Kulcsok jel√∂l√©se</h3>
<pre><code>var test = {
    &#39;case&#39;: &#39;Kulcssz√≥ vagyok, ez√©rt stringk√©nt kell le√≠rnod&#39;,
    delete: &#39;√ân is az vagyok&#39; // SyntaxError
};</code></pre>
<p>Az objektumok mez≈ënevei mind stringk√©nt, mind egyszer≈± sz√∂vegk√©nt (Ford.: aposztr√≥fok n√©lk√ºl)
le√≠rhat√≥ak. A JavaScript √©rtelmez≈ë hib√°ja miatt, a fenti k√≥d azonban <code>SyntaxErrort</code> eredm√©nyez ECMAScript 5 el≈ëtti verzi√≥ eset√©n.</p>
<p>Ez a hiba onnan ered, hogy a <code>delete</code> egy <em>kulcssz√≥</em>, viszont √©rdemes <em>string liter√°lk√©nt</em>
le√≠rni, hogy helyesen meg√©rts√©k a r√©gebbi JavaScript motorok is.</p>
</div></article><article id="object.prototype"><h2>A Protot√≠pus</h2><div><p>A JavaScript nem a klasszikus √∂r√∂kl≈ëd√©st haszn√°lja, hanem egy √∫n. <em>protot√≠pusos</em>
sz√°rmaztat√°st haszn√°l.</p>
<p>M√≠g ezt gyakran a JavaScript legnagyobb hib√°i k√∂z√∂tt tartj√°k sz√°mon, val√≥j√°ban
ez a sz√°rmaztat√°si modell j√≥val kifejez≈ëbb, mint klasszikus bar√°tja.
Ezt jelzi, hogy p√©ld√°ul sokkal k√∂nnyebb meg√©p√≠teni a klasszikus modellt, alapul v√©ve
a protot√≠pusos modellt, m√≠g a ford√≠tott ir√°ny kivitelez√©se igencsak neh√©zkes lenne.</p>
<p>A JavaScript az egyetlen sz√©les k√∂rben elterjedt nyelv, amely ezt a sz√°rmaztat√°st
haszn√°lja, √≠gy mindenk√©pp id≈ët kell sz√°nni a k√©t modell k√∂zti k√ºl√∂nbs√©g meg√©rt√©s√©re.</p>
<p>Az els≈ë felt≈±n≈ë k√ºl√∂nbs√©g, hogy ez a fajta sz√°rmaztat√°s <em>protot√≠pus l√°ncokat</em> 
haszn√°l.</p>
<aside>
<p><strong>Megj.:</strong> Egyszer≈±en a <code>Bar.prototype = Foo.prototype</code> utas√≠t√°st haszn√°lva, mind a 
k√©t objektum <strong>ugyanazon</strong> a protot√≠pus objektumon fog osztozni. √çgy azt√°n ha b√°rki k√∂z√ºl√ºk
megv√°ltoztatja ezt a protot√≠pust, az a v√°ltoz√°s a m√°sik objektum m≈±k√∂d√©s√©t is befoly√°solja,
ami √°ltal√°ban nem egyezik meg a k√≠v√°nt m≈±k√∂d√©ssel.</p>
</aside>
<pre><code>function Foo() {
    this.value = 42;
}
Foo.prototype = {
    method: function() {}
};

function Bar() {}

// Be√°ll√≠tjuk a Bar protot√≠pus√°t a Foo egy √∫j p√©ld√°ny√°ra
Bar.prototype = new Foo(); // !
Bar.prototype.foo = &#39;Hello World&#39;;

// Be√°ll√≠tjuk a Bar konstruktor√°t
Bar.prototype.constructor = Bar;

var test = new Bar(); // √∫j Bar p√©ld√°ny l√©trehoz√°sa

// A kapott protot√≠pus l√°nc
test [instance of Bar]
    Bar.prototype [instance of Foo]
        { foo: &#39;Hello World&#39;, value: 42 }
        Foo.prototype
            { method: ... }
            Object.prototype
                { toString: ... /* stb. */ }</code></pre>
<p>A fenti k√≥dban a <code>test</code> objektum mind a <code>Bar.prototype</code> √©s <code>Foo.prototype</code>
protot√≠pusokb√≥l sz√°rmazik, √≠gy lesz hozz√°f√©r√©se a <code>method</code> nev≈± f√ºggv√©nyhez amely
a <code>Foo</code> protot√≠pus√°ban lett defini√°lva. A <code>value</code> mez≈ëh√∂z szint√©n lesz hozz√°f√©r√©se,
amely akkor j√∂tt l√©tre, amikor (sz√°m szerint) <strong>egy</strong> √∫j <code>Foo</code> p√©ld√°nyt hoztunk l√©tre.
√ârdemes √©szrevenni hogy a <code>new Bar()</code> kifejez√©s <strong>nem</strong> hoz l√©tre egy √∫j <code>Foo</code> p√©ld√°nyt
minden alkalommal, azonban √∫jrahaszn√°lja azt az egyetlen (//!) inicilaliz√°lt <code>Foo</code> p√©dl√°nyunkat. √çgy az √∂sszes <code>Bar</code> p√©ld√°ny <em>egy √©s ugyanazt</em> a <code>value</code> mez≈ët (√©s
√©rt√©ket) fogja haszn√°lni.</p>
<aside>
<p><strong>Megj.:</strong> <strong>Ne</strong> haszn√°ld a <code>Bar.prototype = Foo</code> kifejez√©st, mivel ez nem
a <code>Foo</code> protot√≠pus√°ra fog mutatni, hanem mag√°ra a <code>Foo</code> f√ºggv√©nyre, mint objektumra.
√çgy a protot√≠pus l√°nc a <code>Function.prototype</code>-ra fog futni a <code>Foo.prototype</code> helyett.
Ekkor, a <code>method</code> f√ºggv√©ny nem lesz benne a protot√≠pus l√°ncban.</p>
</aside>
<h3 id="mez-k-keres-se">Mez≈ëk keres√©se</h3>
<p>Amikor olyan utas√≠t√°st adunk ki, amellyel egy objektum mez≈ëj√©t keress√ºk, a
JavaScript <strong>felfele</strong> bej√°rja az eg√©sz protot√≠pus l√°ncot, am√≠g meg nem tal√°lja
a k√©rt mez≈ët.</p>
<p>Hogyha el√©ri a l√°nc legtetej√©t - nevezetesen az <code>Object.prototype</code>-t √©s m√©g
ekkor sem tal√°lja a k√©rt mez≈ët, akkor az <a href="#core.undefined">undefined-dal</a> fog
visszat√©rni.</p>
<h3 id="a-prototype-mez-">A Prototype mez≈ë</h3>
<p>Alapj√°raton, a JavaScript a prototype nev≈± mez≈ët haszn√°lja a protot√≠pus l√°ncok
kialak√≠t√°s√°hoz, de ett≈ël f√ºggetlen√ºl ez is ugyanolyan mez≈ë mint a t√∂bbi, √©s 
<strong>b√°rmilyen</strong> √©rt√©ket be lehet neki √°ll√≠tani. Viszont a primit√≠v t√≠pusokat egyszer≈±en
figyelmen k√≠v√ºl fogja hagyni a feldolgoz√≥.</p>
<pre><code>function Foo() {}
Foo.prototype = 1; // nincs hat√°sa</code></pre>
<p>Az objektumok megad√°sa, mint azt a fentebbi p√©ld√°ban l√°thattuk, hat√°ssal van a prototype
mez≈ëkre √©s ezeknek az √°t√°ll√≠t√°s√°val bele lehet sz√≥lni a protot√≠pus l√°ncok kialak√≠t√°s√°ba.</p>
<h3 id="teljes-tm-ny">Teljes√≠tm√©ny</h3>
<p>√ârtelemszer≈±en, min√©l nagyobb a protot√≠pus l√°nc, ann√°l tov√°bb tart egy-egy mez≈ë
felkeres√©se, √©s ez rossz hat√°ssal lehet a k√≥d teljes√≠tm√©ny√©re. Emellett, ha egy
olyan mez≈ët pr√≥b√°lunk el√©rni, amely nincs az adott objektum p√©ld√°nyban, az mindig
a teljes l√°nc bej√°r√°s√°t fogja eredm√©nyezni.</p>
<p>Vigy√°zat! Akkor is bej√°rjuk a teljes l√°ncot, amikor egy objektum mez≈ëin pr√≥b√°lunk <a href="#object.forinloop">iter√°lni</a>.</p>
<h3 id="nat-v-protot-pusok-b-v-t-se">Nat√≠v protot√≠pusok b≈ëv√≠t√©se</h3>
<p>Egy gyakran elk√∂vetett hiba, hogy az <code>Object.prototype</code> protot√≠pust vagy egy m√°sik el≈ëre
defini√°lt protot√≠pust pr√≥b√°lunk kieg√©sz√≠teni √∫j k√≥ddal.</p>
<p>Ezt <a href="http://en.wikipedia.org/wiki/Monkey_patch">monkey patching</a>-nek is h√≠vj√°k, √©s akt√≠van ker√ºlend≈ë, mivel megt√∂ri 
az <em>egys√©gbe z√°r√°s</em> elv√©t. Hab√°r ezt a technik√°t olyan n√©pszer≈± framework-√∂k
is haszn√°lj√°k, mint a <a href="http://prototypejs.org/">Prototype</a>, ett≈ël f√ºggetlen√ºl ne hagyjuk magunkat cs≈ëbe h√∫zni;
nincs √©sszer≈± indok arra, hogy √∂sszezavarjuk a be√©p√≠tett t√≠pusokat, tov√°bbi 
<em>nem standard</em> saj√°t funkcionalit√°ssal.</p>
<p>Az <strong>egyetlen</strong> √©sszer≈± haszn√°lati indok a nat√≠v protot√≠pusokba ny√∫l√°sra az lehet, 
hogy megpr√≥b√°ljuk szimul√°lni az √∫j JavaScript motorok szolg√°ltat√°sait r√©gebbi t√°rsaikon, p√©ld√°ul az <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach"><code>Array.forEach</code></a> implement√°l√°s√°val.</p>
<h3 id="z-r-sk-nt">Z√°r√°sk√©nt</h3>
<p><strong>Nagyon fontos</strong> meg√©rteni a protot√≠pusos sz√°rmaztat√°si modellt, miel≈ëtt olyan
k√≥dot pr√≥b√°ln√°nk √≠rni, amely megpr√≥b√°lja kihaszn√°lni a saj√°toss√°gait. Nagyon
oda kell figyelni a protot√≠pusl√°nc hossz√°ra - osszuk fel t√∂bb kis l√°ncra ha
sz√ºks√©ges - hogy elker√ºlj√ºk a teljes√≠tm√©ny probl√©m√°kat. Tov√°bb√°, a nat√≠v
protot√≠pusokat <strong>soha</strong> ne eg√©sz√≠ts√ºk ki, eg√©szen addig am√≠g nem akarunk
JavaScript motorok k√∂z√∂tti kompatibilit√°si probl√©m√°kat √°thidalni.</p>
</div></article><article id="object.hasownproperty"><h2><code>hasOwnProperty</code></h2><div><p>Hogy meg tudjuk n√©zni egy adott objektum saj√°t mez≈ëit - azokat a mez≈ëket, amelyek
az objektumon <em>k√∂zvetlen√ºl</em> vannak defini√°lva, √©s nem valahol a 
<a href="#object.prototype">protot√≠pus l√°ncon</a> -, a <code>hasOwnProperty</code> f√ºggv√©ny haszn√°lata 
aj√°nlott, amelyet az √∂sszes objektum am√∫gy is √∂r√∂k√∂l az <code>Object.prototype</code>-b√≥l.</p>
<aside>
<p><strong>Megj.:</strong> Vicces programoz√≥k miatt, <strong>nem</strong> biztos hogy el√©g lesz megn√©zni hogy 
egy adott mez≈ë <code>undefined</code>-e. Mivel lehet hogy ekkor maga a mez≈ë l√©tezik, csak valaki
konkr√©tan az √©rt√©k√©t <code>undefined</code>-ra √°ll√≠totta.</p>
</aside>
<p>A <code>hasOwnProperty</code> f√ºggv√©ny az egyetlen olyan dolog amelyik an√©lk√ºl tudja ellen≈ërizni
az objektum mez≈ëit, hogy megpr√≥b√°ln√° bej√°rni a protot√≠pus l√°ncot.</p>
<pre><code>// Az Object.prototype beszennyez√©se
Object.prototype.bar = 1;
var foo = {goo: undefined};

foo.bar; // 1
&#39;bar&#39; in foo; // igaz

foo.hasOwnProperty(&#39;bar&#39;); // hamis
foo.hasOwnProperty(&#39;goo&#39;); // igaz</code></pre>
<p>Hogy meg√©rts√ºk a fontoss√°g√°t, egyed√ºl a <code>hasOwnProperty</code> tudja hozni a korrekt
√©s elv√°rt eredm√©nyeket mez≈ëellen≈ërz√©s szempontj√°b√≥l. Egyszer≈±en <strong>nincs m√°s</strong> 
m√≥dja annak, hogy kiz√°rjuk a sz≈±r√©s√ºnkb≈ël azokat a mez≈ëket amelyek nem az objektumon, 
hanem valahol feljebb, a protot√≠pus l√°ncon lettek defini√°lva.</p>
<h3 id="a-hasownproperty-mint-mez-">A <code>hasOwnProperty</code> mint mez≈ë</h3>
<p>A JavaScript persze nem v√©di mag√°t a <code>hasOwnProperty</code> nevet, √≠gy egy j√≥kedv≈±
programoz√≥ban mindig megvan a lehet≈ës√©g, hogy √≠gy nevezze el a saj√°t f√ºggv√©ny√©t.
Ennek kiker√ºl√©se √©rdek√©ben aj√°nlott mindig a <code>hasOwnProperty</code>-re <em>k√≠v√ºlr≈ël</em> hivatkozni
(√ârtsd: A hackelt -saj√°t hasOwnPropertyvel ell√°tott- objektum kontextus√°n k√≠v√ºli objektum hasOwnPropertyj√©t h√≠vjuk meg).</p>
<pre><code>var foo = {
    hasOwnProperty: function() {
        return false;
    },
    bar: &#39;Mordor itt kezd≈ëdik&#39;
};

foo.hasOwnProperty(&#39;bar&#39;); // mindig hamissal t√©r vissza

// Haszn√°lhatjuk egy m√°sik objektum hasOwnPropertyj√©t, 
// hogy megh√≠vjuk a foo-n.
({}).hasOwnProperty.call(foo, &#39;bar&#39;); // ez m√°r igaz

// Szint√©n j√≥ megold√°s lehet k√∂zvetlen√ºl az 
// Object prototypej√°b√≥l h√≠vni ezt a f√ºggv√©nyt.
Object.prototype.hasOwnProperty.call(foo, &#39;bar&#39;); // ez is igaz</code></pre>
<h3 id="konkl-zi-">Konkl√∫zi√≥</h3>
<p>A <code>hasOwnProperty</code> haszn√°lata az <strong>egyetlen</strong> megb√≠zhat√≥ m√≥dszer annak eld√∂nt√©s√©re,
hogy egy mez≈ë k√∂zvetlen√ºl az objektumon lett-e l√©trehozva. Melegen aj√°nlott a 
<code>hasOwnProperty</code>-t <strong>minden</strong> <a href="#object.forinloop"><code>for in</code> ciklusban</a> haszn√°lni.
Haszn√°lat√°val ugyanis elker√ºlhetj√ºk a kont√°r m√≥don kieg√©sz√≠tett nat√≠v protot√≠pusokb√≥l
fakad√≥ esetleges hib√°kat, amire az im√©nt l√°ttunk p√©ld√°t.</p>
</div></article><article id="object.forinloop"><h2>A <code>for in</code> ciklus</h2><div><p>Csak √∫gy, mint a j√≥ √∂reg <code>in</code> oper√°tor, a <code>for in</code> is bej√°rja az eg√©sz
protot√≠pus l√°ncot, amikor egy objektum mez≈ëin pr√≥b√°ln√°nk iter√°lni.</p>
<aside>
<p><strong>Megjegyz√©s:</strong> A <code>for in</code> ciklus <strong>nem</strong> fog iter√°lni azokon a mez≈ëk√∂n,
amelyeknek az <code>enumerable</code> tulajdons√°ga <code>false</code>-ra van √°ll√≠tva. P√©ld√°ul a 
<code>length</code> mez≈ë nem ker√ºl az iter√°ci√≥ba amikor egy t√∂mb√∂n iter√°ln√°nk v√©gig.</p>
</aside>
<pre><code>// M√©rgezz√ºk Object.prototype-ot!
Object.prototype.bar = 1;

var foo = {moo: 2};
for(var i in foo) {
    console.log(i); // mind a moo √©s bar is ki√≠r√°sra ker√ºl
}</code></pre>
<p>Mivel -h√°la √©gnek- mag√°nak a <code>for in</code> ciklusnak a m≈±k√∂d√©s√©t nem lehet befoly√°solni,
√≠gy m√°s m√≥dszert kell tal√°lnunk ahhoz hogy sz√°m≈±zz√ºk a v√°ratlan mez≈ëket a ciklus magb√≥l.
(√ârtsd: Azokat amelyek a protot√≠pus l√°ncon cs√ºcs√ºlnek csak). Ezt pedig az <code>Object.prototype</code>-ban
lak√≥ <a href="#object.hasownproperty"><code>hasOwnProperty</code></a> f√ºggv√©ny haszn√°lat√°val √©rhetj√ºk el.</p>
<aside>
<p><strong>Fontoljuk meg:</strong> Mivel a <code>for in</code> mindig bej√°rja a teljes protot√≠pus l√°ncot,
√≠gy minn√©l t√∂bb elemet adunk a sz√°rmaztat√°si l√°ncunkba, ann√°l lassabban fog tekerni.</p>
</aside>
<h3 id="sz-r-s-haszn-lata-a-hasownproperty-vel">Sz≈±r√©s haszn√°lata a <code>hasOwnProperty</code>-vel</h3>
<pre><code>// m√©g mindig a fenti foo-n√°l tartunk
for(var i in foo) {
    if (foo.hasOwnProperty(i)) {
        console.log(i);
    }
}</code></pre>
<p>Ez az egyetlen helyes √∫tja annak, hogy az objektum saj√°t mez≈ëin iter√°ljunk csak v√©gig.
Mivel a <code>hasOwnProperty</code>-t haszn√°ljuk, √≠gy csak a v√°rt <code>moo</code>-t fogja ki√≠rni. Teh√©n j√≥
k√≥dunk van! Hogyha a <code>hasOwnProperty</code>-t kihagyn√°nk, a k√≥dunk ki lenne t√©ve nem v√°rt
hib√°knak, amik pl. abb√≥l fakadnak, hogy valaki ocsm√°nyul kiterjesztette az
<code>Object.prototype</code>-t.</p>
<p>P√©ld√°ul, ha a <a href="http://www.prototypejs.org/">Prototype</a> framework√∂t haszn√°ljuk, √©s nem ilyen st√≠lusban √≠rjuk a
ciklusainkat, a hib√°k szinte garant√°ltak, ugyanis ≈ëk saj√°t sz√°j√≠z√ºkre kiterjesztik az
<code>Object.prototype</code>-t.</p>
<h3 id="konkl-zi-">Konkl√∫zi√≥</h3>
<p>A <code>hasOwnProperty</code> haszn√°lata er≈ësen javasolt. Soha ne √©lj√ºnk pozit√≠v
felt√©telez√©sekkel a fut√≥ k√≥dot illet≈ëen, f≈ëleg olyan d√∂nt√©sekben nem √©rdemes
orosz rulettezni, mint hogy kiterjeszti-e valaki a nat√≠v protot√≠pusokat vagy nem.
Mert √°ltal√°ban igen.</p>
</div></article></section><section id="function"><!-- Introduction--><header id="function.intro"><h1>F√ºggv√©nyek</h1></header><!-- Articles--><article id="function.general"><h2>F√ºggv√©ny deklar√°ci√≥k √©s kifejez√©sek</h2><div><p>A f√ºggv√©nyek JavaScriptben egyben objektumok is. Ez azt jelenti, hogy
ugyan√∫gy lehet ≈ëket passzolgatni, mint b√°rmelyik m√°s √©rt√©keket. Ezt a featuret
gyakran haszn√°lj√°k arra, hogy egy <em>n√©vtelen (callback) f√ºggv√©nyt</em> √°tadjunk 
egy m√°sik -aszinkron- f√ºggv√©ny param√©terek√©nt.</p>
<h3 id="a-f-ggv-ny-deklar-ci-">A <code>f√ºggv√©ny</code> deklar√°ci√≥</h3>
<pre><code>function foo() {}</code></pre>
<p>Ez a f√ºggv√©ny felker√ºl a scope tetej√©re (<a href="#function.scopes">hoisting</a>), miel≈ëtt a k√≥d v√©grehajt√°sa megt√∂rt√©nne. √çgy abban a scope-ban, ahol <em>defini√°lt√°k</em>, <em>mindenhol</em> el√©rhet≈ë, 
m√©g abban a tr√ºkk√∂s esetben is, hogyha a k√≥d azon pontj√°n h√≠vjuk ezt a f√ºggv√©nyt, miel≈ëtt
defini√°ltuk volna (l√°tsz√≥lag).</p>
<pre><code>foo(); // √çgy is m≈±k√∂dik
function foo() {}</code></pre>
<h3 id="a-f-ggv-ny-kifejez-s-expression-">A <code>f√ºggv√©ny</code> kifejez√©s (expression)</h3>
<pre><code>var foo = function() {};</code></pre>
<p>A fentebbi p√©ld√°ban egy <em>n√©vtelen</em> f√ºggv√©nyt adunk √©rt√©k√ºl a foo v√°ltoz√≥nak. </p>
<pre><code>foo; // &#39;undefined&#39;
foo(); // TypeError hiba
var foo = function() {};</code></pre>
<p>Hab√°r ebben a p√©ld√°ban a <code>var</code> deklar√°ci√≥ fut√°s el≈ëtt a k√≥d tetej√©re k√∫szik,
ett≈ël f√ºggetlen√ºl a foo mint f√ºggv√©ny megh√≠v√°sakor hib√°t fogunk kapni.</p>
<p>Ugyanis a deklar√°ci√≥ felk√∫szott, azonban az √©rt√©kad√°s csak fut√°sid≈ëben fog megt√∂rt√©nni,
addig is a foo v√°ltoz√≥ √©rt√©ke <a href="#core.undefined">undefined</a> marad. Az undefinedot pedig hi√°ba h√≠vjuk f√ºggv√©nyk√©nt, TypeErrort kapunk v√©geredm√©ny√ºl.</p>
<h3 id="n-vvel-ell-tott-f-ggv-ny-kifejez-s">N√©vvel ell√°tott f√ºggv√©ny kifejez√©s</h3>
<p>Egy m√°sik √©rdekes eset, amikor n√©vvel ell√°tott f√ºggv√©nyeket adunk √©rt√©k√ºl v√°ltoz√≥knak.</p>
<pre><code>var foo = function bar() {
    bar(); // M≈±k√∂dik
}
bar(); // ReferenceError</code></pre>
<p>Ebben a p√©ld√°ban a <code>bar</code>t √∂nmag√°ban nem lehet el√©rni egy k√ºls≈ë scope-b√≥l (utols√≥ sor), 
mivel egyb≈ël √©rt√©k√ºl adtuk a <code>foo</code> v√°ltoz√≥nak. Ennek ellen√©re a <code>bar</code>on bel√ºl el√©rhet≈ë
a <code>bar</code> n√©v. A tanuls√°g az, hogy a f√ºggv√©ny √∂nmag√°t <em>mindig</em> el√©ri a saj√°t scopej√°n bel√ºl, √©s ez a JavaScriptben tal√°lhat√≥ <a href="#function.scopes">n√©vfelold√°snak</a> k√∂sz√∂nhet≈ë.</p>
</div></article><article id="function.this"><h2>A <code>this</code> m√°gikus m≈±k√∂d√©se</h2><div><p>A <code>this</code> kicsit m√°sk√©pp m≈±k√∂dik a JavaScriptben, mint ahogy azt megszokhattuk
m√°s nyelvekben. Ugyanis pontosan <strong>√∂t f√©le</strong> m√≥dja lehet annak, hogy a <code>this</code> 
√©ppen mire utal a nyelvben.</p>
<h3 id="a-glob-lis-hat-k-r">A Glob√°lis hat√≥k√∂r</h3>
<pre><code>this;</code></pre>
<p>Amikor glob√°lis hat√≥k√∂rben van haszn√°lva a <code>this</code>, akkor pontosan a <em>glob√°lis</em> objektumra utal.</p>
<h3 id="f-ggv-ny-h-v-skor">F√ºggv√©ny h√≠v√°skor</h3>
<pre><code>foo();</code></pre>
<p>Itt a <code>this</code> megint a <em>glob√°lis</em> objektumra fog utalni.</p>
<aside class="es5"><p><strong>ES5 Megjegyz√©s:</strong> Strict m√≥dban a glob√°lis eset <strong>nem l√©tezik</strong> t√∂bb√©.
Ezekben az esetekben a <code>this</code> √©rt√©ke undefined lesz.</p>
</aside>
<h3 id="elj-r-s-h-v-sakor">Elj√°r√°s h√≠v√°sakor</h3>
<pre><code>test.foo(); </code></pre>
<p>Ebben a p√©ld√°ban a <code>this</code> a <code>test</code> objektumra fog hivatkozni.</p>
<h3 id="konstuktor-h-v-sakor">Konstuktor h√≠v√°sakor</h3>
<pre><code>new foo(); </code></pre>
<p>Ha a f√ºggv√©ny h√≠v√°s√°t a <code>new</code> kulcssz√≥val el≈ëzz√ºk meg, akkor a f√ºggv√©ny  <a href="#function.constructors">konstruktork√©nt</a> fog viselkedni. A f√ºggv√©nyen bel√ºl, a <code>this</code>
az <em>√∫jonnan l√©trehozott</em> <code>Objektumra</code> fog hivatkozni.</p>
<h3 id="a-this-explicit-be-ll-t-sa">A <code>this</code> explicit be√°ll√≠t√°sa</h3>
<pre><code>function foo(a, b, c) {}

var bar = {};
foo.apply(bar, [1, 2, 3]); // ugyanaz mint egy sorral lejjebb
foo.call(bar, 1, 2, 3); // argumentumok: a = 1, b = 2, c = 3</code></pre>
<p>A <code>Function.prototype</code>-ban lev≈ë <code>call</code> vagy <code>apply</code> haszn√°latakor azt√°n elszabadul a pokol üòÄ.
Ezekben az esetekben ugyanis a this a foo h√≠v√°sakor <strong>egzaktan</strong> be lesz √°ll√≠tva az apply/call
els≈ë argumentum√°ra. </p>
<p>Ennek eredm√©nyk√©pp az el≈ëz≈ëekben eml√≠tett <em>Elj√°r√°s h√≠v√°sakor</em> r√©sz <strong>nem</strong> √©rv√©nyes,
a <code>foo</code> fentebbi megh√≠v√°sakor a <code>this</code> √©rt√©ke a <code>bar</code> objektumra lesz be√°ll√≠tva.</p>
<aside>
<p><strong>Megj.:</strong> A <code>this</code> kulcssz√≥t <strong>nem lehet</strong> <code>Objektum</code> liter√°l l√©trehoz√°sakor arra haszn√°lni,
hogy mag√°ra az objektumra hivatkozzon.
√çgy a <code>var obj = {me: this}</code> k√≥dban a <code>me</code> <strong>nem fog</strong> a <code>this</code>-re hivatkozni, ugyanis
ez az eset nem tartozik egyikhez sem a fent megtal√°lhat√≥ √∂t k√∂z√ºl.</p>
</aside>
<h3 id="gyakori-buktat-k">Gyakori buktat√≥k</h3>
<p>M√≠g a fent megtal√°lhat√≥ eseteknek van gyakorlatban vett √©rtelme, az els≈ë
a nyelv rossz designj√°ra utal, ugyanis ennek <strong>soha</strong> nem lesz semmilyen 
praktikus felhaszn√°l√°si m√≥dja.</p>
<pre><code>Foo.method = function() {
    function test() {
        // A this itt a glob√°lis ojjektum.
    }
    test();
};</code></pre>
<p>Gyakori hiba, hogy √∫gy gondolj√°k a fenti p√©ld√°ban az emberek, hogy a <code>this</code> a <code>test</code> f√ºggv√©nyen
bel√ºl az ≈ët k√∂r√ºlvev≈ë <code>Foo</code>-ra fog mutatni, pedig <strong>nem</strong>.</p>
<p>Megold√°sk√©pp, hogy a <code>Foo</code>-hoz hozz√°f√©rhess√ºk a <code>test</code>-en bel√ºl, sz√ºks√©gszer≈± egy v√°ltoz√≥t
lok√°lisan elhelyezni a <code>method</code>-on bel√ºl, ami m√°r val√≥ban a k√≠v√°nt <code>this</code>-re (<code>Foo</code>-ra) mutat.</p>
<pre><code>Foo.method = function() {
    var that = this;
    function test() {
        // Haszn√°ljuk a that-et a this helyett
    }
    test();
};</code></pre>
<p>A <code>that</code> tuladjonk√©ppen egy mezei v√°ltoz√≥n√©v (nem kulcssz√≥), de sokszor haszn√°lj√°k arra,
hogy egy m√°sik <code>this</code>-re hivatkozzanak vele. A <a href="#function.closures">closure-√∂kkel</a> kombin√°lva
ez a m√≥dszer arra is haszn√°lhat√≥, hogy <code>this</code>-eket passzolgassunk a vakvil√°gban √©s m√©g tov√°bb.</p>
<h3 id="elj-r-sok-rt-k-l-ad-sa">Elj√°r√°sok √©rt√©k√ºl ad√°sa</h3>
<p>Egy m√°sik koncepci√≥ ami <strong>nem</strong> fog a JavaScriptben m≈±k√∂dni, az az alias f√ºggv√©nyek l√©trehoz√°sa, ami tulajdonk√©ppen egy f√ºggv√©ny m√°sik n√©vhez val√≥ <strong>k√∂t√©s√©t</strong> jelenten√©.</p>
<pre><code>var test = someObject.methodTest;
test();</code></pre>
<p>Az els≈ë eset miatt a <code>test</code> egy sima f√ºggv√©nyh√≠v√°sk√©nt m≈±k√∂dik, azonban a <code>this</code> √©rt√©ke
a f√ºggv√©nyen bel√ºl a tov√°bbiakban <strong>nem</strong> a <code>someObject</code> lesz.    </p>
<p>Els≈ëre a <code>this</code> al√°bbi m√≥don val√≥ ut√°nk√∂t√©se (late binding) nem t≈±nik j√≥ √∂tletnek.
Azonban ez az, amit≈ël a <a href="#object.prototype">protot√≠pusos √∂r√∂kl≈ëd√©s</a> is m≈±k√∂dni tud, 
ami a nyelv egyik f≈ë er≈ëss√©ge.</p>
<pre><code>function Foo() {}
Foo.prototype.method = function() {};

function Bar() {}
Bar.prototype = Foo.prototype;

new Bar().method();</code></pre>
<p>Amikor a <code>method</code> megh√≠v√≥dik a <code>Bar</code> p√©ld√°nyak√©nt, a <code>this</code> pontosan a <code>Bar</code>
megfelel≈ë p√©ld√°ny√°ra fog mutatni.</p>
</div></article><article id="function.closures"><h2>Closure-√∂k √©s referenci√°k</h2><div><p>A JavaScript nyelv egyik leger≈ëteljesebb tulajdons√°ga a <em>closure</em>-√∂k haszn√°lat√°ban rejlik.
Ezek haszn√°lat√°val a hat√≥k√∂r√∂k egym√°sba √°gyazhat√≥ak, √©s egy bels≈ë hat√≥k√∂r mindig hozz√°f√©r
az ≈ët k√∂r√ºlvev≈ë, k√ºls≈ë hat√≥k√∂r v√°ltoz√≥ihoz. Miut√°n JavaScriptben egyetlen dologgal lehet
hat√≥k√∂r√∂ket kifejezni, √©s ez a <a href="#function.scopes">f√ºggv√©ny</a> (bizony az if, try/catch √©s hasonl√≥ blokkok <strong>nem</strong> jelentenek √∫j hat√≥k√∂rt, mint pl. a Javaban), az √∂sszes funkci√≥ closure-k√©nt szerepel.</p>
<h3 id="priv-t-v-ltoz-k-emul-l-sa">Priv√°t v√°ltoz√≥k emul√°l√°sa</h3>
<pre><code>function Counter(start) {
    var count = start;
    return {
        increment: function() {
            count++;
        },

        get: function() {
            return count;
        }
    }
}

var foo = Counter(4);
foo.increment();
foo.get(); // 5</code></pre>
<p>Ebben a p√©ld√°ban a <code>Counter</code> <strong>k√©t</strong> closure-rel t√©r vissza: az <code>increment</code> √©s
a <code>get</code> f√ºggv√©nnyel. Mind a k√©t f√ºggv√©ny <strong>referenci√°t</strong> t√°rol a <code>Counter</code> hat√≥k√∂rre,
√©s √≠gy mindketten hozz√°f√©rnek a <code>count</code> v√°ltoz√≥hoz, ami ebben a hat√≥k√∂rben lett
defini√°lva.</p>
<h3 id="mi-rt-m-k-dnek-a-priv-t-v-ltoz-k-">Mi√©rt m≈±k√∂dnek a priv√°t v√°ltoz√≥k?</h3>
<p>Mivel a JavaScriptben egyszer≈±en <strong>nem</strong> lehet hat√≥k√∂rre refer√°lni, vagy hat√≥k√∂rt
√©rt√©k√ºl adni, √≠gy ez√©rt szint√©n lehetetlen el√©rni az im√©nti <code>count</code> v√°ltoz√≥t a k√ºlvil√°g sz√°m√°ra.
Egyetlen m√≥d van a megsz√≥l√≠t√°s√°ra, ezt pedig l√°ttuk a fentebbi k√©t closure-√∂n bel√ºl.</p>
<pre><code>var foo = new Counter(4);
foo.hack = function() {
    count = 1337;
};</code></pre>
<p>A fentebbi k√≥d <strong>nem</strong> fogja megv√°ltoztatni a <code>Counter</code> hat√≥k√∂r <code>count</code> v√°ltoz√≥j√°t,
mivel a <code>foo.hack</code> mez≈ë <strong>nem abban</strong> a hat√≥k√∂rben lett l√©trehozva. Ehelyett, okosan,
l√©tre fogja hozni, vagy fel√ºl fogja √≠rni a <em>glob√°lis</em> <code>count</code> v√°ltoz√≥t (window.count).</p>
<h3 id="closure-k-haszn-lata-ciklusokban">Closure-√∂k haszn√°lata ciklusokban</h3>
<p>Az egyik leggyakoribb hiba, amit el lehet k√∂vetni, az a closure-√∂k ciklusokban val√≥ haszn√°lata.
Annak is azon speci√°lis esete amikor a ciklus indexv√°ltoz√≥j√°t szeretn√©nk lem√°solni a closure-√∂n bel√ºl.</p>
<pre><code>for(var i = 0; i &lt; 10; i++) {
    setTimeout(function() {
        console.log(i);  
    }, 1000);
}</code></pre>
<p>A fenti k√≥dr√©szlet marh√°ra <strong>nem</strong> a sz√°mokat fogja ki√≠rni <code>0</code>-t√≥l <code>9</code>-ig, de ink√°bb
a <code>10</code>-et fogja t√≠zszer ki√≠rni.</p>
<p>Ugyanis a bels≈ë <em>n√©vtelen</em> f√ºggv√©ny egy <strong>referenci√°t</strong> fog t√°rolni a k√ºls≈ë <code>i</code> v√°ltoz√≥ra, √©s
akkor, amikor v√©g√ºl a <code>console.log</code> sor lefut, a <code>for loop</code> m√°r v√©gzett az eg√©sz ciklussal,
√≠gy az <code>i</code> √©rt√©ke <code>10</code>-re lesz be√°ll√≠tva.</p>
<p>Ahhoz, hogy a v√°rt m≈±k√∂d√©st kapjuk (teh√°t a sz√°mokat 0-t√≥l 9-ig), sz√ºks√©gszer≈± az <code>i</code> v√°ltoz√≥
√©rt√©k√©t <strong>lem√°solni</strong>.</p>
<h3 id="a-referencia-probl-ma-elker-l-se">A referencia probl√©ma elker√ºl√©se</h3>
<p>Az el≈ëz≈ë probl√©m√°ra megold√°st √∫gy lehet j√≥l adni, hogy az utas√≠t√°soknak megfelel≈ëen 
lem√°soljuk a ciklusv√°ltoz√≥t, √∫gy hogy a jelenlegi ciklusmag√∂t k√∂rbevessz√ºk egy <a href="#function.scopes">n√©vtelen
f√ºggv√©nnyel</a>.</p>
<pre><code>for(var i = 0; i &lt; 10; i++) {
    (function(e) {
        setTimeout(function() {
            console.log(e);  
        }, 1000);
    })(i);
}</code></pre>
<p>A k√ºls≈ë (wrapper) n√©vtelen f√ºggv√©ny √≠gy azonnal megh√≠v√≥dik az <code>i</code> ciklusv√°ltoz√≥val, mint param√©terrel,
√©s √≠gy mindig egy m√°solatot fog kapni az <code>i</code> v√°ltoz√≥ <strong>√©rt√©k√©r≈ël</strong>, amit ≈ë <code>e</code> n√©ven em√©szt tov√°bb.</p>
<p>√çgy a <code>setTimeout</code>ban l√©v≈ë n√©vtelen f√ºggv√©ny mindig az <code>e</code> nev≈± referenci√°ra fog mutatni, aminek az √©rt√©ke √≠gy m√°r <strong>nem</strong> v√°ltozik meg a ciklus fut√°sa sor√°n.</p>
<p>Egy m√°sik lehets√©ges √∫t a megold√°shoz az, hogy egy wrapper f√ºggv√©nyt visszat√©r√≠t√ºnk a setTimeoutb√≥l, aminek ugyanaz lesz a hat√°sa, mint a fentebbi p√©ld√°nak.</p>
<pre><code>for(var i = 0; i &lt; 10; i++) {
    setTimeout((function(e) {
        return function() {
            console.log(e);
        }
    })(i), 1000)
}</code></pre>
</div></article><article id="function.arguments"><h2>Az <code>arguments</code> objektum</h2><div><p>Minden f√ºggv√©nyhat√≥k√∂rben hozz√°f√©rhet≈ë az <code>arguments</code> nev≈± speci√°lis v√°ltoz√≥,
amely azon argumentumok list√°j√°t tartalmazza, amelyekkel a f√ºggv√©nyt megh√≠vt√°k.</p>
<aside>
<p><strong>Megjegyz√©s:</strong> Abban a tr√ºkk√∂s esetben, hogyha a f√ºggv√©nyhat√≥k√∂r√∂n bel√ºl valahogy
defini√°ljuk az <code>arguments</code>-et mint nevet, ak√°r v√°ltoz√≥k√©nt (<code>var</code>ral), vagy a f√ºggv√©ny 
param√©terek√©nt, akkor ez a speci√°lis <code>arguments</code> objektum nem lesz l√©trehozva.</p>
</aside>
<p>Lehet hogy √∫gy n√©z ki, de az <code>arguments</code> objektum <strong>nem</strong> egy <code>t√∂mb</code>. L√°tsz√≥lag hasonl√≠t r√°,
mivel van p√©ld√°ul egy <code>length</code> nev≈± mez≈ëje, de igaz√°b√≥l nem az <code>Array.prototype</code>-b√≥l &quot;sz√°rmazik&quot;,
hanem tiszt√°n az <code>Object</code>-b≈ël.</p>
<p>Itt j√∂n a tr√ºkk l√©nyege, hogy ennek k√∂sz√∂nhet≈ëen <strong>nem</strong> haszn√°lhat√≥ak rajta a standard
t√∂mb m≈±veletek mint p√©ld√°ul a <code>push</code>, <code>pop</code> vagy a <code>slice</code>. M√≠g a sima <code>for</code> ciklusos iter√°l√°s
m≈±k√∂dik itt is, ahhoz hogy az el≈ëbb eml√≠tett m≈±veleteket is tudjuk rajta haszn√°lni, √°t kell
konvert√°lni egy val√≥di <code>Array</code> objektumm√°.</p>
<h3 id="t-mbb-konvert-l-s">T√∂mbb√© konvert√°l√°s</h3>
<p>Ez a k√≥dr√©szlet egy √∫j <code>Array</code> objektumm√° var√°zsolja az emlegetett <code>arguments</code> szamarat.</p>
<pre><code>Array.prototype.slice.call(arguments);</code></pre>
<p>De, ez a konverzi√≥ meglehet≈ësen <strong>lass√∫</strong>, √≠gy egy√°ltal√°n <strong>nem aj√°nlott</strong> teljes√≠tm√©ny kirtikus
alkalmaz√°sok √≠r√°sakor.</p>
<h3 id="argumentumok-kezel-se">Argumentumok kezel√©se</h3>
<p>A k√∂vetkez≈ë m√≥dszer aj√°nlott arra az esetre, hogy ha az egyik f√ºggv√©ny param√©tereit egy-az-egyben
√°t szeretn√©nk adni egy m√°sik f√ºggv√©ny sz√°m√°ra.</p>
<pre><code>function foo() {
    bar.apply(null, arguments);
}
function bar(a, b, c) {
    // sok okos k√≥d ide
}</code></pre>
<p>Egy m√°sik tr√ºkk arra, hogy teljesen f√ºggetlen wrapper f√ºggv√©nyeket gy√°rtsunk, a <code>call</code>
√©s <code>apply</code> egy√ºttes haszn√°lata.</p>
<pre><code>function Foo() {}

Foo.prototype.method = function(a, b, c) {
    console.log(this, a, b, c);
};

// Elk√©sz√≠ti a &quot;method&quot; (this) f√ºggetlen verzi√≥j√°t
// Ezeket kapja param√©ter√ºl: this, arg1, arg2...argN
Foo.method = function() {

    // Eredm√©ny: Foo.prototype.method.call(this, arg1, ...argN)
    Function.call.apply(Foo.prototype.method, arguments);
};</code></pre>
<h3 id="param-terek-s-argumentum-indexek">Param√©terek √©s argumentum indexek</h3>
<p>A h√°tt√©rben az <code>arguments</code> objektum minden egyes index√©re (elem√©re) egy <em>getter</em> √©s egy <em>setter</em>
f√ºggv√©nyt is kap, csak √∫gy ahogy a f√ºggv√©ny param√©tereit is fel√ºl tudjuk √≠rni, illetve eltudjuk √©rni.</p>
<p>Ennek eredm√©nyek√©pp, az <code>arguments</code> objektumon v√©ghezvitt v√°ltoztat√°sok szinkronban
v√°ltoztatj√°k a f√ºggv√©ny n√©vvel ell√°tott param√©tereit is.</p>
<pre><code>function foo(a, b, c) {
    arguments[0] = 2;
    a; // 2

    b = 4;
    arguments[1]; // 4

    var d = c;
    d = 9;
    c; // 3
}
foo(1, 2, 3);</code></pre>
<h3 id="teljes-tm-ny-m-toszok-s-tr-kk-k">Teljes√≠tm√©ny m√≠toszok √©s tr√ºkk√∂k</h3>
<p>Ahogy m√°r azt kor√°bban k√∂rvonalaztuk, az <code>arguments</code> objektum csak akkor nem j√∂n l√©tre,
hogyha a f√ºggv√©nyhat√≥k√∂r√∂n bel√ºl defini√°lunk egy v√°ltoz√≥t ezzel a n√©vvel, vagy a f√ºggv√©ny√ºnk
egyik param√©ter√©nek ezt a nevet v√°lasztjuk.</p>
<p>Azonban a <em>getterek</em> √©s <em>setterek</em> mindig l√©trej√∂nnek, de ez ne zavarjon meg minket, mert
semmif√©le befoly√°sa nincs a teljes√≠tm√©nyre, pl√°ne olyan k√≥dban ahol sokkal t√∂bb mindennel
is foglalkozunk, mint az <code>arguments</code> objetkumhoz val√≥ hozz√°f√©r√©s.</p>
<aside class="es5"><p><strong>ES5 Megjegyz√©s:</strong> Ezek a <strong>getterek</strong> √©s <strong>setterek</strong> nem j√∂nnek l√©tre strict m√≥dban.</p>
</aside>
<p>Hab√°r, egyetlen eset van, amelynek komoly hat√°sa lehet a k√≥d teljes√≠tm√©ny√©re a modern
JavaScript motorokban. Ez pedig az <code>arguments.callee</code> haszn√°lata.</p>
<pre><code>function foo() {
    // ..csin√°lunk valamit
    arguments.callee; // ezzel a f√ºggv√©ny objektummal
    arguments.callee.caller; // √©s ennek a h√≠v√≥j√°val..
}

function bigLoop() {
    for(var i = 0; i &lt; 100000; i++) {
        foo(); // √çgy viszont nem lehet behelyettes√≠teni ide...
    }
}</code></pre>
<p>A fenti k√≥dban a <code>foo</code> hely√©re nem lehet egyszer≈±en behelyettes√≠teni a <a href="http://en.wikipedia.org/wiki/Inlining">f√ºggv√©ny t√∂rzs√©t</a>,
mivel a f√ºggv√©ny t√∂rzs√©nek fogalma kell legyen mind mag√°r√≥l, mind az ≈ë h√≠v√≥j√°r√≥l. Ez nem csak
hogy azt akad√°lyozza meg, hogy a behelyettes√≠t√©ssel nyerj√ºnk egy kis t√∂bblet performanci√°t,
de az egys√©gbe z√°r√°s elv√©t is er≈ësen keresztbev√°gja, hiszen a f√ºggv√©ny √≠gy er≈ësen t√°maszkodni
fog a h√≠v√≥ k√∂rnyezet√©re (kontextus√°ra).</p>
<p>Emiatt is, az <code>arguments.callee</code>, vagy b√°rmely mez≈ëj√©nek haszn√°lata <strong>er≈ësen ker√ºlend≈ë</strong>.</p>
<aside class="es5"><p><strong>ES5 Okoskod√°s:</strong> Strict m√≥dban, az <code>arguments.callee</code> kifejez√©s egy <code>TypeError</code> hib√°t fog dobni,
mivel a haszn√°lata elavult.</p>
</aside>
</div></article><article id="function.constructors"><h2>Konstruktorok</h2><div><p>Csak √∫gy, mint minden m√°s, a konstruktorok m≈±k√∂d√©se szint√©n k√ºl√∂nb√∂zik 
a megszokott√≥l. Itt minden f√ºggv√©nyh√≠v√°s amelyet a <code>new</code> kulcssz√≥ el≈ëz meg, 
konstruktor h√≠v√°snak sz√°m√≠t.</p>
<p>A <code>this</code> √©rt√©ke a konstruktoron - h√≠vott f√ºggv√©nyen - bel√ºl az √∫jonnan l√©trehozott objektumra
mutat. Az <strong>√∫j</strong> objektum <a href="#object.prototype">protot√≠pusa</a> a konstruktor f√ºggv√©ny <code>protot√≠pus√°val</code> fog megegyezni.</p>
<p>Ha a konstruktor f√ºggv√©nyben nincs <code>return</code> utas√≠t√°s, akkor automatikusan a <code>this</code> √©rt√©k√©vel t√©r vissza - a l√©trehozott objektummal.</p>
<pre><code>function Foo() {
    this.bla = 1;
}

Foo.prototype.test = function() {
    console.log(this.bla);
};

var test = new Foo();</code></pre>
<p>A fenti k√≥dban a <code>Foo</code> f√ºggv√©nyt, mint konstruktort h√≠vjuk meg, ami a test v√°ltoz√≥ban
egy √∫j objektumot fog eredm√©nyezni. Ennek az objektumnak a <code>protot√≠pusa</code> a Foo protot√≠pusa lesz.</p>
<p>Tr√ºkk√∂s ugyan, de ha m√©gis van <code>return</code> utas√≠t√°s az √©ppen konstru√°lt f√ºggv√©nyben, akkor
a f√ºggv√©ny h√≠v√°sa az annak megfelel≈ë √©rt√©kkel fog visszat√©rni, de <strong>csak</strong> akkor, ha a 
visszat√©r√≠tett √©rt√©k <code>Objektum</code> t√≠pus√∫.</p>
<pre><code>function Bar() {
    return 2;
}
new Bar(); // ez egy √∫j √ºres objektum lesz: {}, a 2 helyett

function Test() {
    this.value = 2;

    return {
        foo: 1
    };
}
new Test(); // ez a { foo: 1 } objektumot fogja eredm√©nyezni</code></pre>
<p>Hogyha kihagyjuk a <code>new</code> kulcssz√≥ haszn√°lat√°t, a f√ºggv√©ny <strong>nem</strong> egy √∫j objektummal fog visszat√©rni.</p>
<pre><code>function Foo() {
    this.bla = 1; // ez a glob√°lis objektumon √°ll√≠t
}
Foo(); // undefined</code></pre>
<p>A <a href="#function.this"><code>this</code></a> JavaScript beli m≈±k√∂d√©s√©nek k√∂sz√∂nhet≈ëen, m√©g ha le is
fut az el≈ëbbi k√≥d, akkor a <code>this</code> hely√©re a <em>glob√°lis objektumot</em> k√©pzelj√ºk.</p>
<h3 id="gy-rak-factory-k-">Gy√°rak (Factory-k)</h3>
<p>Ahhoz, hogy teljesen el tudjuk hagyni a <code>new</code> kulcssz√≥ haszn√°lat√°t, a konstruktor
f√ºggv√©ny explicit √©rt√©kkel kell visszat√©rjen.</p>
<pre><code>function Bar() {
    var value = 1;
    return {
        method: function() {
            return value;
        }
    }
}
Bar.prototype = {
    foo: function() {}
};

new Bar();
Bar();</code></pre>
<p>Mindk√©t <code>Bar</code>-ra t√∂rt√©n≈ë h√≠v√°sm√≥d ugyanazt fogja eredm√©nyezni. Kapunk √°ltaluk 
egy √∫jonnan l√©trehozott objektumot, amelynek lesz egy <code>method</code> nev≈± mez≈ëje,
ami egy√©bir√°nt egy <a href="#function.closures">Closure</a>.</p>
<p>Azt is √©rdekes itt megjegyezni, hogy a <code>new Bar()</code> h√≠v√°s <strong>nem</strong> befoly√°solja a
visszat√©r√≠tett objektum protot√≠pus√°t. Mivel a protot√≠pus csak az √∫jonnan 
l√©trehozott objektumon l√©tezik, amit a <code>Bar</code> nem t√©r√≠t vissza (mivel egy explicit
√©rt√©ket ad vissza).</p>
<p>A fenti p√©ld√°ban nincs funkcion√°lis k√ºl√∂nbs√©g ak√∂z√∂tt hogy ki√≠rjuk-e a <code>new</code>
var√°zssz√≥t avagy nem.</p>
<h3 id="-j-objektumok-l-trehoz-sa-gy-rakon-kereszt-l">√öj objektumok l√©trehoz√°sa gy√°rakon kereszt√ºl</h3>
<p>Gyakran bevett m√≥dszer egy projetkben, hogy a <code>new</code> var√°zssz√≥ haszn√°lat√°t 
teljesen elhagyjuk, mert a ki√≠r√°s√°nak elfelejt√©se bugokhoz vezetne.</p>
<p>Ennek √©rdek√©ben egy √∫j objektum l√©trehoz√°s√°hoz ink√°bb egy gy√°rat kell 
implement√°lni, √©s annak a belsej√©ben l√©trehozni az √∫j objektumot. </p>
<pre><code>function Foo() {
    var obj = {};
    obj.value = &#39;blub&#39;;

    var private = 2;
    obj.someMethod = function(value) {
        this.value = value;
    }

    obj.getPrivate = function() {
        return private;
    }
    return obj;
}</code></pre>
<p>A fenti k√≥d ugyan ellen√°ll√≥ a hi√°nyz√≥ <code>new</code> kulcssz√≥ hib√°j√°t illet≈ëen √©s 
megfelel≈ëen haszn√°l <a href="#function.closures">priv√°t v√°ltoz√≥kat</a>, √©rdemes 
megeml√≠teni a dolgok kontra r√©sz√©t is.</p>
<ol>
<li>T√∂bb mem√≥ri√°t haszn√°l, mivel az √≠gy l√©trehozott objektumok <strong>nem</strong>
osztj√°k meg a protot√≠pusukat egym√°s k√∂z√∂tt.</li>
<li>A sz√°rmaztat√°s macer√°s, mivel a gy√°r k√©nytelen ilyenkor lem√°solni
az √∂sszes sz√°rmaztatand√≥ met√≥dust egy m√°sik objektumr√≥l, vagy ezt az objektumot
be kell √°ll√≠tsa a l√©trehozott √∫j objektum protot√≠pus√°nak.</li>
<li>Az a megk√∂zel√≠t√©s miszerint egy kifelejtett <code>new</code> kulcssz√≥ miatt eldobjuk
az objektum teljes protot√≠pus√°t, ellenkezik a nyelv szellemis√©g√©vel.</li>
</ol>
<h3 id="-sszefoglal-">√ñsszefoglal√≥</h3>
<p>A <code>new</code> var√°zssz√≥ kihagy√°sa ugyan bugokhoz vezethet, de ez <strong>nem</strong> megfelel≈ë indok
arra hogy ez√©rt eldobjuk a protot√≠pusok haszn√°lat√°t. V√©geredm√©nyben mindig
az fog d√∂nteni a k√ºl√∂nb√∂z≈ë st√≠lusok megv√°laszt√°sa k√∂z√∂tt, hogy mire van
sz√ºks√©ge √©ppen az aktu√°lis programunknak. Egy dolog az√©rt elengedhetetlen√ºl
fontos, ez pedig hogy megv√°lasszuk melyik st√≠lust fogjuk haszn√°lni objektumok
l√©trehoz√°sra, √©s ezt <strong>konzisztensen</strong> haszn√°ljuk a teljes megold√°son kereszt√ºl.</p>
</div></article><article id="function.scopes"><h2>N√©vterek √©s hat√≥k√∂r√∂k</h2><div><p>Hab√°r l√°tsz√≥lag a kapcsos z√°r√≥jelek jelentik a blokkok hat√°rait JavaScriptben, 
fontos megjegyezni hogy <strong>nincsen</strong> blokk szint≈± hat√≥k√∂r, csakis <em>f√ºggv√©ny hat√≥k√∂r√∂k</em>
l√©teznek.</p>
<pre><code>function test() { // ez egy hat√≥k√∂r
    for(var i = 0; i &lt; 10; i++) { // ez meg nem
        // utas√≠t√°sok...
    }
    console.log(i); // 10
}</code></pre>
<aside>
<p><strong>Megjegyz√©s</strong>: Amikor a <code>{...}</code> jel√∂l√©s nem √©rt√©kad√°sban, return utas√≠t√°sban vagy
f√ºggv√©ny argumentumk√©nt szerepel, akkor blokk utas√≠t√°sk√©nt lesz √©rtelmezve √©s
nem objektum liter√°lk√©nt. Ez a sz√©p tulajdons√°g az <a href="#core.semicolon">automatikus pontosvessz≈ë
gener√°l√°ssal</a> kar√∂ltve nehezen √©szrevehet≈ë hib√°khoz vezethet.</p>
</aside>
<p>A nyelvben nincsenek be√©p√≠tett n√©vterek, ami azt jelenti hogy minden, egyetlen
<em>glob√°lisan megosztott</em> n√©vt√©rben ker√ºl deklar√°l√°sra.</p>
<p>Ak√°rh√°nyszor egy v√°ltoz√≥ra hivatkozunk, a JavaScript elkezdi felfele utazva
megkeresni hat√≥k√∂r√∂k√∂n, am√≠g csak meg nem tal√°lja. Hogyha el√©rj√ºk
a glob√°lis hat√≥k√∂rt √©s m√©g mindig nem tal√°ljuk a keresett v√°ltoz√≥t, akkor egy
<code>ReferenceError</code> hib√°val gazdagodik a fut√°sid≈ënk.</p>
<h3 id="a-glob-lis-v-ltoz-k-csap-sa">A glob√°lis v√°ltoz√≥k csap√°sa</h3>
<pre><code>// A script
foo = &#39;42&#39;;

// B script
var foo = &#39;42&#39;</code></pre>
<p>√ârdemes √©szrevenni, hogy a fenti k√©t scriptnek <strong>nem</strong> ugyanaz a hat√°sa. Az A script
egy <code>foo</code> nev≈± v√°ltoz√≥t vezet be a <em>glob√°lis</em> hat√≥k√∂rben, a B script pedig egy <code>foo</code>
nev≈± v√°ltoz√≥t deklar√°l az <em>≈ë hat√≥k√∂r√©ben</em>.</p>
<p>M√©gegyszer teh√°t, ez a kett≈ë <strong>nem</strong> <em>ugyanazt jelenti</em>: a <code>var</code> elhagy√°s√°nak j√≥p√°r
bel√°thatatlan k√∂vetkezm√©nye is lehet.</p>
<pre><code>// glob√°lis hat√≥k√∂r
var foo = 42;
function test() {
    // lok√°lis hat√≥k√∂r
    foo = 21;
}
test();
foo; // 21</code></pre>
<p>Itt, a <code>var</code> elhagy√°sa azt eredm√©nyezi, hogy a <code>test</code> f√ºggv√©ny mindig fel√ºl√≠rja
a glob√°lis hat√≥k√∂rben defini√°lt <code>foo</code> v√°ltoz√≥ √©rt√©k√©t. Hab√°r ez els≈ëre nem t≈±nik
nagy dolognak, ha a <code>var</code>okat t√∂bb sz√°z sornyi JavaScript k√≥db√≥l hagyjuk el, az 
olyan hib√°khoz vezethet, amit m√©g az any√≥sunknak se k√≠v√°nn√°nk.</p>
<pre><code>// glob√°lis hat√≥k√∂r
var items = [/* random lista */];
for(var i = 0; i &lt; 10; i++) {
    subLoop();
}

function subLoop() {
    // a subLoop hat√≥k√∂re
    for(i = 0; i &lt; 10; i++) { // hi√°nyzik a var
        // elk√©peszt≈ë dolgokat m≈±vel√ºnk itt
    }
}</code></pre>
<p>Enn√©l a k√≥dn√°l a k√ºls≈ë ciklus az els≈ë <code>subLoop</code> h√≠v√°s ut√°n meg√°ll, mivel a <code>subLoop</code>
fel√ºl√≠rja az <code>i</code> v√°ltoz√≥ glob√°lis √©rt√©k√©t. Hogyha a m√°sodik <code>for</code> ciklusban haszn√°ltuk
volna <code>var</code>-t azzal k√∂nnyen elker√ºlhett√ºk volna ezt a hib√°t. <strong>Sose</strong> hagyjuk el a <code>var</code> utas√≠t√°st, ha csak nem direkt az a <em>k√≠v√°nt hat√°s</em>, hogy befoly√°soljuk a 
k√ºls≈ë hat√≥k√∂rt.</p>
<h3 id="lok-lis-v-ltoz-k">Lok√°lis v√°ltoz√≥k</h3>
<p>K√©tf√©lek√©pp (√©s nem t√∂bb m√≥don) lehet lok√°lis v√°ltoz√≥kat JavaScriptben le√≠rni; ez vagy a <a href="#function.general">f√ºggv√©ny</a> param√©ter vagy a <code>var</code> utas√≠t√°s.</p>
<pre><code>// glob√°lis hat√≥k√∂r
var foo = 1;
var bar = 2;
var i = 2;

function test(i) {
    // a test f√ºggv√©ny lok√°lis hat√≥k√∂re
    i = 5;

    var foo = 3;
    bar = 4;
}
test(10);</code></pre>
<p>Itt a <code>foo</code> √©s <code>i</code> lok√°lis v√°ltoz√≥k a <code>test</code> hat√≥k√∂r√©n bel√ºl, viszont a <code>bar</code>os
√©rt√©kad√°s fel√ºl fogja √≠rni a hasonl√≥ nev≈± glob√°lis v√°ltoz√≥t.</p>
<h3 id="hoisting">Hoisting</h3>
<p>A JS <strong>hoistolja</strong> (megemeli) a deklar√°ci√≥kat. Ez azt jelenti hogy minden <code>var</code>
utas√≠t√°s √©s <code>f√ºggv√©ny</code> deklar√°ci√≥ az ≈ët k√∂r√ºlvev≈ë hat√≥k√∂r tetej√©re ker√ºl.</p>
<pre><code>bar();
var bar = function() {};
var someValue = 42;

test();
function test(data) {
    if (false) {
        goo = 1;

    } else {
        var goo = 2;
    }
    for(var i = 0; i &lt; 100; i++) {
        var e = data[i];
    }
}</code></pre>
<p>A fenti k√≥d √°talakul egy m√°sik form√°ra miel≈ëtt lefutna. A JavaScript felmozgatja
a <code>var</code> utas√≠t√°sokat √©s a <code>f√ºggv√©ny</code> deklar√°ci√≥kat, az ≈ëket k√∂r√ºlvev≈ë legk√∂zelebbi
hat√≥k√∂r tetej√©be.</p>
<pre><code>// a var utas√≠t√°sok felker√ºlnek ide
var bar, someValue; // alapb√≥l mindegyik &#39;undefined&#39; √©rt√©k≈± lesz

// a f√ºggv√©ny deklar√°ci√≥ is felker√ºl ide
function test(data) {
    var goo, i, e; // ezek is felker√ºlnek
    if (false) {
        goo = 1;

    } else {
        goo = 2;
    }
    for(i = 0; i &lt; 100; i++) {
        e = data[i];
    }
}

bar(); // Ez TypeErrorral elsz√°ll, mivel a bar m√©g &#39;undefined&#39;
someValue = 42; // az √©rt√©kad√°sokat nem piszk√°lja a hoisting
bar = function() {};

test();</code></pre>
<p>A hi√°nyz√≥ blokk hat√≥k√∂r t√©nye nem csak azt eredm√©nyezi, hogy a <code>var</code> utas√≠t√°sok
kiker√ºlnek a ciklusmagokb√≥l, hanem az <code>if</code> utas√≠t√°sok kimenetele is megj√≥solhatatlan
lesz.</p>
<p>Hab√°r √∫gy l√°tszik az eredeti k√≥dban, hogy az <code>if</code> utas√≠t√°s a <code>goo</code> <em>glob√°lis 
v√°ltoz√≥t</em> m√≥dos√≠tja, a hoisting ut√°n l√°tjuk hogy val√≥j√°ban a <em>lok√°lis v√°ltoz√≥ra</em>
lesz befoly√°ssal. Tr√ºkk√∂s.</p>
<p>A <em>hoisting</em> tud√°sa n√©lk√ºl valaki azt hihetn√©, hogy az al√°bbi k√≥d egy <code>ReferenceError</code>
-t fog eredm√©nyezni.</p>
<pre><code>// n√©zz√ºk meg hogy a SomeImportantThing inicializ√°lva lett-e
if (!SomeImportantThing) {
    var SomeImportantThing = {};
}</code></pre>
<p>Persze ez m≈±k√∂dik, annak k√∂sz√∂nhet≈ëen hogy a <code>var</code> utas√≠t√°s a <em>glob√°lis hat√≥k√∂r</em>
tetej√©re lett mozgatva.</p>
<pre><code>var SomeImportantThing;

// m√°s k√≥dok m√©g inicializ√°lhatj√°k az el≈ëbbi v√°ltoz√≥t itt...

// ellen≈ërizz√ºk hogy l√©tezik-e
if (!SomeImportantThing) {
    SomeImportantThing = {};
}</code></pre>
<h3 id="n-vfelold-si-sorrend">N√©vfelold√°si sorrend</h3>
<p>JavaScriptben az √∂sszes hat√≥k√∂rnek -bele√©rtve a <em>glob√°lisat</em> is- megvan a maga
<a href="#function.this"><code>this</code></a> v√°ltoz√≥ja, amelyik mindig az <em>aktu√°lis objektumra</em> utal.</p>
<p>A f√ºggv√©ny hat√≥k√∂r√∂kben van m√©g egy speci√°lis <a href="#function.arguments"><code>arguments</code></a>
v√°ltoz√≥ is mindig defini√°lva, amely a f√ºggv√©nynek √°tadott argumentumokat
tartalmazza.</p>
<p>Hogy hozzunk egy p√©ld√°t, amikor valaki a <code>foo</code> nev≈± v√°ltoz√≥t pr√≥b√°lja el√©rni egy
f√ºggv√©ny hat√≥k√∂r√∂n bel√ºl, a JavaScript az al√°bbi sorrendben fogja keresni az adott
v√°ltoz√≥ nevet.</p>
<ol>
<li>Abban az esetben ha tal√°lunk <code>var foo</code> utas√≠t√°st, haszn√°ljuk azt.</li>
<li>Hogyha b√°rmelyik f√ºggv√©ny param√©ter neve <code>foo</code>, haszn√°ljuk azt.</li>
<li>Hogyha mag√°nak a f√ºggv√©nynek a neve `foo, haszn√°ljuk azt.</li>
<li>Menj√ºnk a k√ºls≈ë hat√≥k√∂rre, √©s kezdj√ºk √∫jra <strong>#1</strong>-t≈ël.</li>
</ol>
<aside>
<p><strong>Megjegyz√©s</strong>: Egy <code>arguments</code> nev≈± f√ºggv√©ny param√©ter <strong>megakad√°lyozza</strong>
a b√©p√≠tett <code>arguments</code> objektum l√©trehoz√°s√°t.</p>
</aside>
<h3 id="n-vterek">N√©vterek</h3>
<p>Hogyha egyetlen glob√°lis n√©vter√ºnk van, akkor egy gyakori probl√©ma lehet az,
hogy n√©v√ºtk√∂z√©sekbe futunk. A JavaScriptben szerencs√©re ez a gond k√∂nnyen
elker√ºlhet≈ë a <em>n√©vtelen wrapper f√ºggv√©nyek</em> haszn√°lat√°val.</p>
<pre><code>(function() {
    // egy &#39;√∂ntartalmaz√≥&#39; n√©vt√©r

    window.foo = function() {
        // egy export√°lt closure
    };

})(); // a f√ºggv√©nyt azonnal v√©gre is hajtjuk</code></pre>
<p>A n√©vtelen f√ºggv√©nyek <a href="#function.general">kifejez√©sekk√©nt</a> vannak √©rtelmezve; √≠gy
ahhoz hogy megh√≠vhat√≥ak legyenek, el≈ësz√∂r ki kell √©rt√©kelni ≈ëket.</p>
<pre><code>( // a f√ºggv√©ny ki√©rt√©kel√©se a z√°r√≥jeleken bel√ºl
function() {}
) // a f√ºggv√©ny objektum visszat√©r√≠t√©se
() // az eredm√©ny megh√≠v√°sa</code></pre>
<p>Persze m√°s kifejez√©sek is haszn√°lhat√≥ak arra, hogy ki√©rt√©kelj√ºk √©s megh√≠vjuk
a f√ºggv√©ny kifejez√©st, amelyek hab√°r szintaxisukban elt√©rnek, ugyan azt eredm√©nyezik.</p>
<pre><code>// M√©g t√∂bb st√≠lus anonymus f√ºggv√©nyek azonnali h√≠v√°s√°hoz...
!function(){}()
+function(){}()
(function(){}());
// √©s a lista folytat√≥dik...</code></pre>
<h3 id="-sszegz-s-l">√ñsszegz√©s√ºl</h3>
<p>Az <em>anonym wrapper f√ºggv√©nyek</em> haszn√°lata er≈ësen aj√°nlott a k√≥d egys√©gbez√°r√°sa 
√©rdek√©ben, saj√°t n√©vt√©r alkot√°s√°hoz. Ez nem csak hogy megv√©di a k√≥dunkat a 
n√©v√ºtk√∂z√©sekt≈ël, de jobb modulariz√°ci√≥hoz is vezet.</p>
<p>Emelett a glob√°lis v√°ltoz√≥k haszn√°lata <strong>nem aj√°nlott</strong>. <strong>B√°rmilyen</strong> fajta 
haszn√°lata rosszul meg√≠rt k√≥dr√≥l √°rulkodik, amelyik k√∂nnyen elt√∂rik √©s nehezen
karbantarthat√≥.</p>
</div></article></section><section id="array"><!-- Introduction--><header id="array.intro"><h1>T√∂mb√∂k</h1></header><!-- Articles--><article id="array.general"><h2>T√∂mb iter√°ci√≥ √©s tulajdons√°gok</h2><div><p>Hab√°r a t√∂mb√∂k a JavaScriptben objektumok, nincsen j√≥ ok arra, hogy a <a href="#object.forinloop"><code>for in</code></a> ciklussal j√°rjuk be ≈ëket. 
Val√≥j√°ban sokkal t√∂bb j√≥ ok van arra, hogy <strong>mi√©rt ne</strong> √≠gy tegy√ºnk.</p>
<aside>
<p><strong>Megjegyz√©s:</strong> A JS t√∂mb√∂k <strong>nem</strong> <em>asszociat√≠v t√∂mb√∂k</em>. A JavaScriptben egyed√ºl
az <a href="#object.general">objektumokkal</a> lehet kulcsokat √©rt√©kekhez rendelni. R√°ad√°sul
am√≠g az asszociat√≠v t√∂mb√∂k <strong>meg≈ërzik</strong> a sorrendj√ºket, az objektumok <strong>nem</strong>.</p>
</aside>
<p>Mivel a <code>for in</code> ciklus a protot√≠pus l√°ncon lev≈ë √∂sszes tulajdons√°gon v√©gigmegy,
√©s mivel az egyetlen √∫t ennek megker√ºl√©s√©re a <a href="#object.hasownproperty"><code>hasOwnProperty</code></a> haszn√°lata, √≠gy majdnem <strong>h√∫sszor</strong> 
lassabb mint egy sima <code>for</code> ciklus.</p>
<h3 id="iter-ci-">Iter√°ci√≥</h3>
<p>Annak √©rdek√©ben, hogy a legjobb teljes√≠tm√©nyt √©rj√ºk el a t√∂mb√∂k√∂n val√≥ iter√°ci√≥ sor√°n,
a legjobb hogyha a klasszikus <code>for</code> ciklust haszn√°ljuk.</p>
<pre><code>var list = [1, 2, 3, 4, 5, ...... 100000000];
for(var i = 0, l = list.length; i &lt; l; i++) {
    console.log(list[i]);
}</code></pre>
<p>M√©g egy √©rdekess√©g van a fenti p√©ld√°ban, ami a t√∂mb hossz√°nak cachel√©s√©t v√©gzi
a <code>l = list.length</code> kifejez√©s haszn√°lat√°val.</p>
<p>Hab√°r a <code>length</code> tulajdons√°g mindig mag√°n a t√∂mb√∂n van defini√°lva, m√©g mindig
lehet egy kis teljes√≠tm√©ny kies√©s amiatt hogy minden iter√°ci√≥ban √∫jra meg kell
keresni ezt a tulajdons√°got. Persze a leg√∫jabb JavaScript motorok <strong>tal√°n</strong>
haszn√°lnak erre optimaliz√°ci√≥t, de nem lehet biztosan megmondani, hogy ahol a k√≥dunk
futni fog, az egy ilyen motor-e vagy sem.</p>
<p>Val√≥j√°ban, a cachel√©s kihagy√°sa azt eredm√©nyezheti, hogy a ciklusunk csak 
<strong>fele olyan gyors</strong> lesz mintha a cachel≈ës megold√°st v√°lasztottuk volna.</p>
<h3 id="a-length-mez-">A <code>length</code> mez≈ë</h3>
<p>M√≠g a <code>length</code> mez≈ë <em>getter</em> f√ºggv√©nye egyszer≈±en csak visszaadja a t√∂mbben
lev≈ë elemek sz√°m√°t, addig a <em>setter</em> f√ºggv√©ny haszn√°lhat√≥ arra (is), hogy
<strong>megcsonk√≠tsuk</strong> a t√∂mb√ºnket.</p>
<pre><code>var foo = [1, 2, 3, 4, 5, 6];
foo.length = 3;
foo; // [1, 2, 3]

foo.length = 6;
foo.push(4);
foo; // [1, 2, 3, undefined, undefined, undefined, 4]</code></pre>
<p>Egy r√∂videbb hossz alkalmaz√°sa csonk√≠tja a t√∂mb√∂t. A nagyobb hossz megad√°sa
√©rtelemszer≈±en n√∂veli.</p>
<h3 id="-sszegz-s-l">√ñsszegz√©s√ºl</h3>
<p>A megfelel≈ë teljes√≠tm√©ny √©rdek√©ben, a <code>for</code> ciklus haszn√°lata √©s a length cachel√©se
aj√°nlott. A <code>for in</code> ciklus haszn√°lata a t√∂mb√∂k√∂n a rosszul meg√≠rt k√≥d jele, amely
tele lehet hib√°kkal, √©s teljes√≠tm√©nyben sem jeleskedik.</p>
</div></article><article id="array.constructor"><h2>Az <code>Array</code> konstruktor</h2><div><p>Mivel az <code>Array</code> konstruktora k√©t√©rtelm≈±en b√°nik a param√©terekkel, melegen
aj√°nlott mindig a t√∂mb liter√°lt - <code>[]</code> jel√∂l√©s - haszn√°lni √∫j t√∂mb√∂k l√©trehoz√°sakor.</p>
<pre><code>[1, 2, 3]; // Eredm√©ny: [1, 2, 3]
new Array(1, 2, 3); // Eredm√©ny: [1, 2, 3]

[3]; // Eredm√©ny: [3]
new Array(3); // Eredm√©ny: []
new Array(&#39;3&#39;) // Eredm√©ny: [&#39;3&#39;]</code></pre>
<p>Abban az esetben, ha ez a konstruktor csak egy <code>sz√°m</code> param√©tert kap, akkor
visszat√©r√©si √©rt√©k√ºl egy olyan t√∂mb√∂t fog l√©trehozni amelynek a <code>length</code> mez≈ëje
akkor√°ra van be√°ll√≠tva, ahogy azt megadtuk az argumentumban. Megjegyzend≈ë hogy
<strong>csak</strong> a <code>length</code> tulajdons√°g lesz ekkor be√°ll√≠tva; az egyes indexek k√ºl√∂n-k√ºl√∂n
nem lesznek inicializ√°lva.</p>
<pre><code>var arr = new Array(3);
arr[1]; // undefined
1 in arr; // hamis, nincs ilyen index</code></pre>
<p>A t√∂mb hossz√°nak k√∂zvetlen √°ll√≠t√°sa am√∫gy is csak el√©g kev√©s esetben
haszn√°lhat√≥ √©rtelmesen, mint p√©ld√°ul al√°bb, hogyha el akarjuk ker√ºlni a 
<code>for ciklus</code> haszn√°lat√°t egy string ism√©tl√©sekor.</p>
<pre><code>new Array(count + 1).join(ismetlendoString);</code></pre>
<h3 id="-sszegz-s-l">√ñsszegz√©s√ºl</h3>
<p>Az <code>Array</code> konstruktor k√∂zvetlen haszn√°lata er≈ësen ker√ºlend≈ë. A liter√°lok haszn√°lata
elfogadott ink√°bb, mivel r√∂videbbek, tiszt√°bb a szintaxisuk √©s olvashat√≥bb k√≥dot
eredm√©nyeznek.</p>
</div></article></section><section id="types"><!-- Introduction--><header id="types.intro"><h1>T√≠pusok</h1></header><!-- Articles--><article id="types.equality"><h2>Egyenl≈ës√©g vizsg√°lat</h2><div><p>A JavaScriptben k√©t k√ºl√∂nb√∂z≈ë megold√°s l√©tezik az objektumok egyenl≈ës√©g√©nek 
vizsg√°lat√°ra</p>
<h3 id="az-egyenl-s-g-oper-tor">Az egyenl≈ës√©g oper√°tor</h3>
<p>Az egyenl≈ës√©g vizsg√°latot v√©gz≈ë (egyik) oper√°tort √≠gy jel√∂lj√ºk: <code>==</code></p>
<p>A JavaScript egy <em>gyeng√©n t√≠pusos</em> nyelv. Ez azt jelenti, hogy az egyenl≈ës√©g
oper√°tor <strong>t√≠pusk√©nyszer√≠t√©st</strong> alkalmaz ahhoz, hogy √∂ssze tudjon hasonl√≠tani
k√©t √©rt√©ket.</p>
<pre><code>&quot;&quot;           ==   &quot;0&quot;           // hamis
0            ==   &quot;&quot;            // igaz
0            ==   &quot;0&quot;           // igaz
false        ==   &quot;false&quot;       // hamis
false        ==   &quot;0&quot;           // igaz
false        ==   undefined     // hamis
false        ==   null          // hamis
null         ==   undefined     // igaz
&quot; \t\r\n&quot;    ==   0             // igaz</code></pre>
<p>A fenti t√°bl√°zat sz√©pen mutatja, hogy mi a t√≠pusk√©nyszer√≠t√©s eredm√©nye, √©s egyben
azt is, hogy mi√©rt rossz szok√°s a <code>==</code> haszn√°lata. Szok√°s szerint, ez megint
olyan f√≠cs√∂r, ami nehezen k√∂vethet≈ë k√≥dhoz vezethet a komplik√°lt konverzi√≥s
szab√°lyai miatt.</p>
<p>Pl√°ne, hogy a k√©nyszer√≠t√©s teljes√≠tm√©ny probl√©m√°khoz is vezet; ugyanis, miel≈ëtt
egy stringet egy sz√°mhoz hasonl√≠tan√°nk azel≈ëtt a karakterl√°ncot √°t kell konvert√°lni
a megfelel≈ë t√≠pusra.</p>
<h3 id="a-szigor-bb-egyenl-s-g-oper-tor">A szigor√∫(bb) egyenl≈ës√©g oper√°tor</h3>
<p>Ez az oper√°tor m√°r <strong>h√°rom</strong> egyenl≈ës√©gjelb≈ël √°ll: <code>===</code>.</p>
<p>Ugyan√∫gy m≈±k√∂dik, mint az el≈ëbbi, kiv√©ve hogy ez a v√°ltozat <strong>nem</strong> alkalmaz
t√≠pusk√©nyszer√≠t√©st az operandusai k√∂z√∂tt.</p>
<pre><code>&quot;&quot;           ===   &quot;0&quot;           // hamis
0            ===   &quot;&quot;            // hamis
0            ===   &quot;0&quot;           // hamis
false        ===   &quot;false&quot;       // hamis
false        ===   &quot;0&quot;           // hamis
false        ===   undefined     // hamis
false        ===   null          // hamis
null         ===   undefined     // hamis
&quot; \t\r\n&quot;    ===   0             // hamis</code></pre>
<p>A fels≈ë eredm√©nyek sokkal egy√©rtelm≈±bbek √©s ennek k√∂sz√∂nhet≈ëen sokkal hamarabb
elt√∂rik a k√≥d egy-egy ellen≈ërz√©sen. Ett≈ël sokkal hibat≈±r≈ëbb lesz
a produktumunk, r√°ad√°sul teljes√≠tm√©nybeli gondjaink sem lesznek.</p>
<h3 id="objektumok-sszehasonl-t-sa">Objektumok √∂sszehasonl√≠t√°sa</h3>
<p>Hab√°r mind a <code>==</code>-t √©s a <code>===</code>-t is egyenl≈ës√©g oper√°tornak h√≠vjuk, elt√©r≈ëen
viselkednek, hogy ha legal√°bb az egyik operandusuk egy objektum.</p>
<pre><code>{} === {};                   // hamis
new String(&#39;foo&#39;) === &#39;foo&#39;; // hamis
new Number(10) === 10;       // hamis
var foo = {};
foo === foo;                 // igaz</code></pre>
<p>Ebben az esetben mindk√©t oper√°tor <strong>identit√°st</strong> √©s <strong>nem</strong> egyenl≈ës√©get 
ellen≈ëriz; teh√°t azt fogj√°k ellen≈ërizni hogy az operandus k√©t oldal√°n
ugyanaz az objektum referencia √°ll-e, mint az <code>is</code> oper√°tor Pythonban
vagy a pointerek √∂sszehasonl√≠t√°sa C-ben. (A ford.: Teh√°t nem azt, hogy a 
k√©t oldalon √°ll√≥ objektumnak p√©ld√°ul ugyanazok-e a mez≈ëi, hanem azt hogy ugyanazon
a mem√≥riac√≠men tal√°lhat√≥-e a k√©t operandus).</p>
<h3 id="-sszegz-s-l">√ñsszegz√©s√ºl</h3>
<p>Azt √©rdemes teh√°t megjegyezni, hogy a <strong>szigor√∫ egyenl≈ës√©g vizsg√°latot</strong> √©rdemes
mindig haszn√°lni. Amikor szeretn√©k t√≠pusk√©nyszer√≠t√©st alkalmazni, akkor azt
ink√°bb tegy√ºk meg <a href="#types.casting">direkt m√≥don</a>, √©s ne a nyelv komplik√°lt
automatikus szab√°lyaira b√≠zzuk magunkat. </p>
</div></article><article id="types.typeof"><h2>A <code>typeof</code> vizsg√°lat</h2><div><p>A <code>typeof</code> oper√°tor (az <a href="#types.instanceof"><code>instanceof</code></a>-al kar√∂ltve) 
lehet≈ës√©g szerint a JavaScript nyelv egyik legnagyobb buktat√≥ja, mivel majdnem
teljesen <strong>rosszul m≈±k√∂dik</strong>.</p>
<p>Hab√°r az <code>instanceof</code>-nak korl√°tozottan m√©g lehet √©rtelme, a <code>typeof</code> oper√°tor
t√©nyleg csak egyetlen praktikus use case-el rendelkezik √©s ez <strong>nem</strong> az, hogy egy
objektum t√≠pusvizsg√°lat√°t elv√©gezz√ºk.</p>
<aside>
<p><strong>Megjegyz√©s:</strong> Mivel a <code>typeof</code> vizsg√°latot ravaszul √∫gy is le lehet √≠rni,
mintha egy f√ºggv√©ny lenne; <code>typeof(obj)</code>, itt jegyezz√ºk meg hogy ez nem
egy f√ºggv√©nyh√≠v√°s. A z√°r√≥jelek ebben a kifejez√©sben √∫gy m≈±k√∂dnek mint √°ltal√°ban,
ki√©rt√©kelik az obj v√°ltoz√≥t √©s visszaadj√°k az √©rt√©k√©t. Ez pedig beker√ºl a 
<code>typeof</code> operandusak√©nt. <strong>Nincsen</strong> <code>typeof</code> f√ºggv√©ny.</p>
</aside>
</div></article><article id="types.instanceof"><h2>Az <code>instanceof</code> oper√°tor</h2><div><p>Az <code>instanceof</code> oper√°tor a k√©t operandus√°nak konstruktorait hasonl√≠tja √∂ssze. 
Csak akkor bizonyul hasznosnak, amikor saj√°t k√©sz√≠t√©s≈± objektumokon alkalmazzuk.
Be√©p√≠tett t√≠pusokon ugyanolyan hasztalan alkalmazni, mint a <a href="#types.typeof">typeof oper√°tort</a>.</p>
<h3 id="saj-t-objektumok-sszehasonl-t-sa">Saj√°t objektumok √∂sszehasonl√≠t√°sa</h3>
<pre><code>function Foo() {}
function Bar() {}
Bar.prototype = new Foo();

new Bar() instanceof Bar; // igaz
new Bar() instanceof Foo; // igaz

// Ez csak a Bar.prototypeot be√°ll√≠tja a Foo fv. objektumra,
// de nem egy kimondott Foo p√©ld√°nyra
Bar.prototype = Foo;
new Bar() instanceof Foo; // hamis</code></pre>
<h3 id="az-instanceof-reakci-ja-nat-v-t-pusokra">Az <code>instanceof</code> reakci√≥ja nat√≠v t√≠pusokra</h3>
<pre><code>new String(&#39;foo&#39;) instanceof String; // igaz
new String(&#39;foo&#39;) instanceof Object; // igaz

&#39;foo&#39; instanceof String; // hamis
&#39;foo&#39; instanceof Object; // hamis</code></pre>
<p>√ârdemes itt megjegyezni hogy az <code>instanceof</code> nem m≈±k√∂dik olyan objektumokon,
amelyek k√ºl√∂nb√∂z≈ë JavaScript kontextusokb√≥l sz√°rmaznak (pl. k√ºl√∂nb√∂z≈ë dokumentumok
a b√∂ng√©sz≈ën bel√ºl), mivel a konstruktoruk nem pontosan ugyanaz az objektum lesz.</p>
<h3 id="-sszegz-s-l">√ñsszegz√©s√ºl</h3>
<p>Az <code>instanceof</code>-ot teh√°t <strong>csak</strong> megegyez≈ë JS kontextusb√≥l sz√°rmaz√≥, saj√°t k√©sz√≠t√©s≈± objektumokn√°l haszn√°ljuk. Minden m√°s felhaszn√°l√°sa ker√ºlend≈ë, csak √∫gy, mint a <a href="#types.typeof"><code>typeof</code></a> oper√°tor eset√©n.</p>
</div></article><article id="types.casting"><h2>T√≠pus kasztol√°s</h2><div><p>El≈ëre k√∂ss√ºk le, hogy a JavaScript egy <em>gyeng√©n t√≠pusos</em> nyelv, √≠gy <strong>ahol
csak tud</strong>, ott <em>t√≠pus k√©nyszer√≠t√©st</em> haszn√°l.</p>
<pre><code>// Ezek igazak
new Number(10) == 10; // A Number.toString() sz√°mm√° lesz
                      // visszaalak√≠tva

10 == &#39;10&#39;;           // A Stringek visszaalakulnak sz√°mm√°
10 == &#39;+10 &#39;;         // M√©gt√∂bb string var√°zslat
10 == &#39;010&#39;;          // √©s m√©gt√∂bb
isNaN(null) == false; // a null var√°zslatosan 0-v√° alakul
                      // ami persze nem NaN

// Ezek hamisak
10 == 010;
10 == &#39;-10&#39;;</code></pre>
<aside class="es5"><p><strong>ES5 Megjegyz√©s:</strong> A <code>0</code>-val kezd≈ëd≈ë sz√°mliter√°lok okt√°lok (8-as sz√°mrendszer).
Az okt√°l t√°mogat√°st az ECMAScript 5 strict m√≥db√≥l <strong>elt√°vol√≠tott√°k</strong></p>
</aside>
<p>Hogy elker√ºlj√ºk a fenti var√°zslatokat, a <a href="#types.equality">szigor√∫ egyenl≈ës√©g ellen≈ërz√©s</a> <strong>melegen</strong> aj√°nlott. Hab√°r ezzel elker√ºlj√ºk
a probl√©m√°k farkasr√©sz√©t, m√©g mindig tartogat a JS gyeng√©n t√≠pusos rendszere
meglepet√©seket.</p>
<h3 id="nat-v-t-pusok-konstruktorai">Nat√≠v t√≠pusok konstruktorai</h3>
<p>A j√≥ h√≠r az, hogy a nat√≠v t√≠pusok, mint a <code>Number</code> √©s a <code>String</code> k√ºl√∂nf√©le
m√≥don viselkednek, hogy ha a <code>new</code> kulcssz√≥val avagy an√©lk√ºl vannak inicializ√°lva.</p>
<pre><code>new Number(10) === 10;     // Hamis, Objektum vs. Sz√°m
Number(10) === 10;         // Igaz, Sz√°m vs. sz√°m
new Number(10) + 0 === 10; // Igaz, az implicit konverzi√≥nak h√°la</code></pre>
<p>Ha egy nat√≠v t√≠pust, mint a <code>Number</code> konstruktork√©nt kezel√ºnk, akkor egy √∫j
<code>Number</code> objektumot kapunk. De ha kihagyjuk a <code>new</code> kulcssz√≥t akkor a <code>Number</code>
egy egyszer≈± konverter f√ºggv√©nyk√©nt fog viselkedni.</p>
<p>R√°ad√°sul a liter√°lok passzolgat√°sakor m√©g t√∂bb t√≠puskonverzi√≥ √ºti fel a fej√©t.</p>
<p>A legjobb megold√°s hogyha a h√°rom t√≠pus valamelyik√©re <strong>expliciten</strong> kasztolunk.</p>
<h3 id="stringre-kasztol-s">Stringre kasztol√°s</h3>
<pre><code>&#39;&#39; + 10 === &#39;10&#39;; // igaz</code></pre>
<p>Egy √ºres string hozz√°f≈±z√©s√©vel k√∂nnyen tudunk egy √©rt√©ket stringg√© kasztolni.</p>
<h3 id="sz-mra-kaszt">Sz√°mra kaszt</h3>
<pre><code>+&#39;10&#39; === 10; // igaz</code></pre>
<p>Az <strong>un√°ris</strong> plusz oper√°tor haszn√°lat√°val lehets√©ges egy √©rt√©ket sz√°mra alak√≠tani.</p>
<h3 id="booleanre-kasztol-s">Booleanre kasztol√°s</h3>
<p>A <strong>nem</strong> oper√°tor k√©tszeri alkalmaz√°s√°val tudunk booleann√© kasztolni.</p>
<pre><code>!!&#39;foo&#39;;   // igaz
!!&#39;&#39;;      // hamis
!!&#39;0&#39;;     // igaz
!!&#39;1&#39;;     // igaz
!!&#39;-1&#39;     // igaz
!!{};      // igaz
!!true;    // igaz</code></pre>
</div></article></section><section id="core"><!-- Introduction--><header id="core.intro"><h1>L√©nyeg</h1></header><!-- Articles--><article id="core.eval"><h2>Mi√©rt Ne Haszn√°ljuk az <code>eval</code>-t</h2><div><p>Az <code>eval</code> (evil) funkci√≥ egy stringbe √°gyazott JavaScript k√≥dot futtat a 
lok√°lis scopeon bel√ºl.</p>
<pre><code>var foo = 1;
function test() {
    var foo = 2;
    eval(&#39;foo = 3&#39;);
    return foo;
}
test(); // 3
foo; // 1</code></pre>
<p>Viszont az <code>eval</code> csak akkor viselkedik √≠gy, hogyha expliciten h√≠vjuk meg
<em>√©s</em> a megh√≠vott funkci√≥ neve val√≥ban <code>eval</code>.</p>
<pre><code>var foo = 1;
function test() {
    var foo = 2;
    var bar = eval;
    bar(&#39;foo = 3&#39;);
    return foo;
}
test(); // 2
foo; // 3</code></pre>
<p>Az <code>eval</code> haszn√°lata ker√ºlend≈ë. A &quot;felhaszn√°l√°sa&quot; az esetek 99.9%-ban 
<strong>mell≈ëzhet≈ë</strong>.</p>
<h3 id="az-eval-ezer-arca">Az <code>eval</code> ezer arca</h3>
<p>A <code>setTimeout</code> √©s <code>setInterval</code> nev≈± <a href="#other.timeouts">timeout f√ºggv√©nyek</a> is
tudnak √∫gy m≈±k√∂dni, hogy els≈ë param√©ter√ºkk√©nt egy stringbe √°gyazott k√≥dot v√°rnak.
Ez a string <strong>mindig</strong> a glob√°lis hat√≥k√∂rben lesz v√©grehajtva, mivel az <code>eval</code>t
√≠gy nem direktben h√≠vjuk meg.</p>
<h3 id="biztons-gi-probl-m-k">Biztons√°gi probl√©m√°k</h3>
<p>Az <code>eval</code> az√©rt is vesz√©lyes, mert <strong>b√°rmilyen</strong> JS k√≥dot v√©grehajt, amit odaadunk
neki. √âppen ez√©rt <strong>sose</strong> haszn√°ljuk olyan k√≥dok v√©grehajt√°s√°ra amiknek az eredete
nem megb√≠zhat√≥/ismeretlen.</p>
<h3 id="-sszegz-s-l">√ñsszegz√©s√ºl</h3>
<p>Soha ne haszn√°ljunk <code>eval</code>t. B√°rmilyen k√≥d m≈±k√∂d√©se, teljes√≠tm√©nye, ill. biztons√°ga
megk√©rd≈ëjelezhet≈ë, amely haszn√°lja ezt a nyelvi elemet. Semmilyen megold√°s
haszn√°lata <strong>nem aj√°nlott</strong> amely els≈ë sorban <code>eval</code>ra √©p√ºl. Ekkor egy <em>jobb
megold√°s</em> sz√ºks√©geltetik, amely nem f√ºgg az <code>eval</code>t√≥l.</p>
</div></article><article id="core.undefined"><h2>Az <code>undefined</code> √©s a <code>null</code></h2><div><p>A JavaScript k√©t √©rt√©ket is tartogat a semmi kifejez√©s√©re, ezek a <code>null</code> √©s az
<code>undefined</code> √©s ezek k√∂z√ºl az ut√≥bbi a hasznosabb.</p>
<h3 id="az-undefined-">Az <code>undefined</code></h3>
<p>Ha az el≈ëbbi bevezet≈ët≈ël nem zavarodt√°l volna √∂ssze; az 
<code>undefined</code> egy t√≠pus amelynek pontosan egy √©rt√©ke van, az <code>undefined</code>.</p>
<p>A nyelvben szint√©n van egy <code>undefined</code> nev≈± glob√°lis v√°ltoz√≥ amelynek az √©rt√©k√©t
hogy-hogy nem <code>undefined</code>-nak h√≠vj√°k. Viszont ez a v√°ltoz√≥ <strong>nem</strong> konstans vagy
kulcssz√≥ a nyelvben. Ez azt jeletni hogy az <em>√©rt√©ke</em> k√∂nnyed√©n fel√ºl√≠rhat√≥.</p>
<aside class="es5"><p><strong>ES5 Megjegyz√©s:</strong> Az <code>undefined</code> ECMAScript 5-ben <strong>t√∂bb√©</strong> <em>nem fel√ºl√≠rhat√≥</em> 
strict m√≥dban, b√°r a neve tov√°bbra is eltakarhat√≥, p√©ld√°ul egy saj√°t f√ºggv√©nnyel
aminek a neve √©ppen <code>undefined</code>.</p>
</aside>
<p>Itt van p√°r p√©lda, hogy mikor is tal√°lkozhatunk az <code>undefined</code> √©rt√©kkel:</p>
<ul>
<li>Az <code>undefined</code> glob√°lis v√°ltoz√≥ el√©r√©sekor</li>
<li>Egy deklar√°lt, de nem inicializ√°lt v√°ltoz√≥ el√©r√©sekor.</li>
<li>Egy f√ºggv√©ny h√≠v√°sakor ez a visszat√©r√©si √©rt√©k, <code>return</code> utas√≠t√°s h√≠j√°n.</li>
<li>Egy olyan <code>return</code> utas√≠t√°s lefut√°sakor, amely nem t√©r√≠t vissza √©rt√©ket.</li>
<li>Nem l√©tez≈ë mez≈ëk lek√©r√©sekor.</li>
<li>Olyan f√ºggv√©ny param√©terek el√©r√©sekor amelyeknek a h√≠v√≥ oldalon nem kaptak √©rt√©ket.</li>
<li>B√°rmikor amikor az <code>undefined</code> √©rt√©k van valaminek be√°ll√≠tva.</li>
<li>B√°rmelyik <code>void(kifejez√©s)</code> utas√≠t√°s futtat√°sakor.</li>
</ul>
<h3 id="-undefined-meg-rz-si-tr-kk-k"><code>undefined</code> meg≈ërz√©si tr√ºkk√∂k</h3>
<p>Mivel az <code>undefined</code> nev≈± glob√°lis v√°ltoz√≥ csak egy m√°solatot t√°rol az 
<code>undefined</code> elnevez√©s≈± √©rt√©kb≈ël, az √©rt√©k√©nek megv√°ltoztat√°sa <strong>nem</strong> √≠rja
fel√ºl az eredeti <code>undefined</code> <em>t√≠pus</em> √©rt√©k√©t.</p>
<p>Ez√©rt, ha valamilyen √©rt√©kkel √∂ssze szeretn√©nk hasonl√≠tani az <code>undefined</code> √©rt√©ket,
nem √°rt hogyha el≈ësz√∂r mag√°t az <code>undefined</code>-ot el tudjuk √©rni.</p>
<p>Egy gyakori technika annak √©rdek√©ben hogy megv√©dj√ºk a k√≥dunkat az 
<code>undefined</code> lehets√©ges fel√ºldefini√°l√°sait√≥l, hogy egy <a href="#function.scopes">n√©vtelen (wrapper)</a> f√ºggv√©nybe
csomagoljuk az eg√©sz k√≥dunkat, amelynek lesz egy direkt √ºres param√©tere.</p>
<pre><code>var undefined = 123;
(function(something, foo, undefined) {
    // az undefined ebben a hat√≥k√∂rben 
    // megint val√≥ban az `undefined` √©rt√©kre refer√°ll.

})(&#39;Hello World&#39;, 42);</code></pre>
<p>Egy m√°sik m√≥dja ennek, hogy haszn√°lunk egy &quot;√ºres&quot; deklar√°ci√≥t a wrapper f√ºggv√©nyen
bel√ºl.</p>
<pre><code>var undefined = 123;
(function(something, foo) {
    var undefined;
    ...

})(&#39;Hello World&#39;, 42);</code></pre>
<p>Az egyetlen k√ºl√∂nbs√©g ebben a v√°ltozatban, hogyha minifik√°ljuk ezt a k√≥dot,
√©s nem defini√°lunk tov√°bbi v√°ltoz√≥kat ezen a r√©szen bel√ºl, akkor ezzel a
v√°ltozattal extra 4 byte &quot;vesztes√©get&quot; szenved√ºnk el.</p>
<h3 id="mikor-haszn-ljunk-null-t">Mikor haszn√°ljunk <code>null</code>t</h3>
<p>Mik√∂zben az <code>undefined</code> a nat√≠v JavaScript megval√≥s√≠t√°sokban ink√°bb a (m√°s 
nyelvekben lev≈ë) trad√≠cion√°lis <em>null</em> helyett haszn√°land√≥, azalatt maga a <code>null</code> 
ink√°bb csak egy k√ºl√∂nb√∂z≈ë adatt√≠pusnak sz√°m√≠t, mindenf√©le k√ºl√∂n√∂s jelent√©s n√©lk√ºl.</p>
<p>Egy p√°r bels≈ë JavaScriptes megold√°sban ugyan haszn√°lj√°k (ahol pl. a protot√≠pus l√°nc v√©g√©t a <code>Foo.prototype = null</code> be√°ll√≠t√°ssal jel√∂lik), de a legt√∂bb esetben ez
felcser√©lhet≈ë az <code>undefined</code>-al.</p>
<p>(A ford.: A <code>null</code> annak az esetnek a jel√∂l√©s√©re hasznos, amikor
egy referencia t√≠pus√∫ v√°ltoz√≥t deklar√°lunk, de m√©g nem adunk neki √©rt√©ket. Pl. a 
<code>var ezObjektumLesz = null</code> kifejez√©s ezt jel√∂li. Teh√°t a null legink√°bb
kezdeti √©rt√©kk√©nt √°llja meg a hely√©t, minden m√°sra ott az <code>undefined</code>)</p>
</div></article><article id="core.semicolon"><h2>Automatic Semicolon Insertion</h2><div><p>B√°r a JavaScriptnek l√°tsz√≥lag C-s szintaxisa van, <strong>m√©gsem</strong> k√∂telez≈ë benne
kirakni a pontosvessz≈ëket, √≠gy (helyenk√©nt) kihagyhat√≥ak a forr√°sb√≥l.
(A ford.: hiszen interpret√°lt nyelv l√©v√©n nincsenek ford√≠t√°si hib√°k, √≠gy 
nyelvi elemek megl√©t√©t sem tudja er≈ëltetni a nyelv)</p>
<p>Itt j√∂n a csel, hogy ennek ellen√©re a JavaScript csak pontosvessz≈ëkkel
√©rtelmezi megfelel≈ëen a be√≠rt k√≥dot. K√∂vetkez√©sk√©pp, a JS <strong>automatikusan</strong>
illeszti be a pontosvessz≈ëket (megpr√≥b√°lja kital√°lni a gondolataink) 
azokra a helyekre, ahol am√∫gy emiatt √©rtelmez√©si hib√°ba futna.</p>
<pre><code>var foo = function() {
} // √©rtelmez√©si hiba, pontosvessz≈ë k√©ne
test()</code></pre>
<p>Az automatikus beilleszt√©s megt√∂rt√©nik, ezut√°n √≠gy √©rtelmez≈ëdik a k√≥d</p>
<pre><code>var foo = function() {
}; // nincs hiba, mindenki √∂r√ºl
test()</code></pre>
<p>Az automatikus beilleszt√©s (ASI) a JavaScript (egyik) <strong>legnagyobb</strong> design
hib√°ja, mivel igen... <em>meg tudja</em> v√°ltoztatni a k√≥d √©rtelmez√©s√©t</p>
<h3 id="hogyan-m-k-dik">Hogyan M≈±k√∂dik</h3>
<p>Az al√°bi k√≥dban nincsen pontosvessz≈ë, √≠gy az √©rtelmez≈ë (parser) feladata kital√°lni,
hogy hova is illessze be ≈ëket.</p>
<pre><code>(function(window, undefined) {
    function test(options) {
        log(&#39;testing!&#39;)

        (options.list || []).forEach(function(i) {

        })

        options.value.test(
            &#39;hossz√∫ string az argumentumban&#39;,
            &#39;m√©g m√©g m√©g m√©g m√©g hossszabbbbbbb&#39;
        )

        return
        {
            foo: function() {}
        }
    }
    window.test = test

})(window)

(function(window) {
    window.someLibrary = {}

})(window)</code></pre>
<p>Al√°bb mutatjuk a &quot;kital√°l√≥s&quot; j√°t√©k eredm√©ny√©t.</p>
<pre><code>(function(window, undefined) {
    function test(options) {

        // Nincs beilleszt√©s, a sorok √∂ssze lettek vonva
        log(&#39;testing!&#39;)(options.list || []).forEach(function(i) {

        }); // &lt;- beilleszt√©s

        options.value.test(
            &#39;hossz√∫ string az argumentumban&#39;,
            &#39;m√©g m√©g m√©g m√©g m√©g hossszabbbbbbb&#39;
        ); // &lt;- beilleszt√©s

        return; // &lt;- beilleszt√©s, elt√∂rik a return kifejez√©s√ºnk
        { // blokk√©nt √©rtelemz≈ëdik

            // n√©v: kifejez√©s form√°tumban √©rtelmez≈ëdik
            foo: function() {} 
        }; // &lt;- beilleszt√©s
    }
    window.test = test; // &lt;- beilleszt√©s

// Ezeket a sorokat √∂sszeilleszti
})(window)(function(window) {
    window.someLibrary = {}; // &lt;- beilleszt√©s

})(window); //&lt;- beilleszt√©s</code></pre>
<aside>
<p><strong>Megjegyz√©s:</strong> A JavaScript √©rtelmez≈ë nem tudja &quot;korrekt√ºl&quot; kezelni azokat
a return kifejez√©seket, amelyek ut√°n k√∂zvetlen √∫j sor √°ll. Hab√°r ez nem biztos hogy 
sz√ºks√©gszer≈±en az ASI hib√°j√°b√≥l t√∂rt√©nik, az√©rt nem egy t√∫l kellemes mell√©khat√°s.</p>
</aside>
<p>Az √©rtelmez≈ë drasztikusan megv√°ltoztatta a fenti k√≥dot. A legt√∂bb esetben a 
beilleszt≈ë <strong>rosszul</strong> tippel.</p>
<p>(A ford.: Semmilyen nyelvben sem j√≥, hogyha hagyjuk hogy a g√©p tal√°lja ki mit
szerett√ºnk volna √≠rni. N√©ma gyereknek az anyja sem √©rti a k√≥dj√°t ugye.)</p>
<h3 id="kezd-z-r-jelek">Kezd≈ë Z√°r√≥jelek</h3>
<p>Az √©rtelmez≈ë <strong>nem</strong> rak be √∫j pontosvessz≈ët, hogyha a sor eleje (nyit√≥) z√°r√≥jellel kezd≈ëdik.</p>
<pre><code>log(&#39;testing!&#39;)
(options.list || []).forEach(function(i) {})</code></pre>
<p>Ez a k√≥d egy sork√©nt √©rtelmez≈ëdik</p>
<pre><code>log(&#39;testing!&#39;)(options.list || []).forEach(function(i) {})</code></pre>
<p>Az es√©lyek arra <strong>el√©g</strong> magasak, hogy a <code>log</code> <strong>nem</strong> egy f√ºggv√©nyt fog visszat√©r√≠teni; √≠gy a fenti k√≥d egy <code>TypeError</code> t√≠pus√∫ hib√°t fog dobni 
<code>undefined is not a function</code> √ºzenettel.</p>
<h3 id="-sszefoglal-sk-pp">√ñsszefoglal√°sk√©pp</h3>
<p>Sz√ºks√©gszer≈±en <strong>soha</strong> ne hagyjuk ki a pontoszvessz≈ëket. Nem √°rt a kapcsos
z√°r√≥jeleket is ugyanazon a soron tartani, mint amelyiken az utas√≠t√°st elkezdt√ºk,
√≠gy nem aj√°nlott az egysoros <code>if</code> / <code>else</code> kifejez√©sek kedv√©√©rt elhagyni
≈ëket. Ezek a szempontok nem csak a k√≥dot (√©s annak olvashat√≥s√°g√°t) tartj√°k
konzisztensen, de megel≈ëzik azt is hogy a JavaScript √©rtelmez≈ë valamit rosszul
&quot;tal√°ljon ki&quot;.</p>
</div></article><article id="core.delete"><h2>A <code>delete</code> Oper√°tor</h2><div><p>R√∂viden, <em>lehetetlen</em> glob√°lis v√°ltoz√≥kat, f√ºggv√©nyeket √©s olyan dolgokat t√∂r√∂lni
JavaScriptben amelyeknek a <code>DontDelete</code> attrib√∫tuma be van √°ll√≠tva.</p>
<h3 id="glob-lis-k-d-s-f-ggv-ny-k-d">Glob√°lis k√≥d √©s F√ºggv√©ny k√≥d</h3>
<p>Amikor egy v√°ltoz√≥/f√ºggv√©ny, glob√°lis vagy 
<a href="#function.scopes">f√ºggv√©ny hat√≥k√∂rben</a> van defini√°lva, 
akkor az vagy az Aktiv√°ci√≥s (Activation) vagy a Glob√°lis (Global) objektum egyik mez≈ëjek√©nt
j√∂n l√©tre.  Az ilyen mez≈ëknek van egy halom attrib√∫tuma, amelyek k√∂z√ºl az egyik 
a <code>DontDelete</code>. A v√°ltoz√≥ √©s f√ºggv√©ny deklar√°ci√≥k a glob√°lis vagy f√ºggv√©ny k√≥don
bel√ºl mindig <code>DontDelete</code> tulajdons√°g√∫ mez≈ëket hoznak l√©tre, √≠gy nem lehet ≈ëket
t√∂r√∂lni.</p>
<pre><code>// glob√°lis v√°ltoz√≥
var a = 1; // A DontDelete be lett √°ll√≠tva
delete a; // hamis
a; // 1

// f√ºggv√©ny:
function f() {} // A DontDelete be lett √°ll√≠tva
delete f; // hamis
typeof f; // &quot;function&quot;

// √∫j √©rt√©kad√°ssal sem megy
f = 1;
delete f; // hamis
f; // 1</code></pre>
<h3 id="explicit-mez-k">Explicit mez≈ëk</h3>
<p>Az expliciten be√°ll√≠tott mez≈ëket persze norm√°lisan lehet t√∂r√∂lni.</p>
<pre><code>// expliciten be√°ll√≠tott mez≈ë
var obj = {x: 1};
obj.y = 2;
delete obj.x; // igaz
delete obj.y; // igaz
obj.x; // undefined
obj.y; // undefined</code></pre>
<p>A fenti p√©ld√°ban az <code>obj.x</code> √©s <code>obj.y</code> t√∂r√∂lhet≈ë, mivel nincs <code>DontDelete</code>
attrib√∫tuma egyik mez≈ënek sem. Ez√©rt m≈±k√∂dik az al√°bbi p√©lda is.</p>
<pre><code>// m≈±k√∂dik, kiv√©ve IE-ben
var GLOBAL_OBJECT = this;
GLOBAL_OBJECT.a = 1;
a === GLOBAL_OBJECT.a; // igaz - egy glob√°lis v√°ltoz√≥
delete GLOBAL_OBJECT.a; // igaz
GLOBAL_OBJECT.a; // undefined</code></pre>
<p>Itt egy tr√ºkk√∂t haszn√°lunk az <code>a</code> t√∂rl√©s√©re. A <a href="#function.this"><code>this</code></a> itt 
a Glob√°lis objektumra mutat, √©s expliciten bevezetj√ºk rajta az <code>a</code> v√°ltoz√≥t, mint
egy mez≈ëj√©t, √≠gy t√∂r√∂lni is tudjuk.</p>
<p>Mint az szok√°s, a fenti k√≥d egy kicsit bugos IE-ben (legal√°bbis 6-8-ig).</p>
<h3 id="f-ggv-ny-argumentumok-s-be-p-tett-dolgaik">F√ºggv√©ny argumentumok √©s be√©p√≠tett dolgaik</h3>
<p>A f√ºggv√©ny argumentumok, az <a href="#function.arguments"><code>arguments</code> objektum</a>
√©s a be√©p√≠tett mez≈ëk szint√©n <code>DontDelete</code> tulajdons√°g√∫ak.</p>
<pre><code>// f√ºggv√©ny argumentumok √©s mez≈ëk
(function (x) {

  delete arguments; // hamis
  typeof arguments; // &quot;object&quot;

  delete x; // hamis
  x; // 1

  function f(){}
  delete f.length; // hamis
  typeof f.length; // &quot;number&quot;

})(1);</code></pre>
<h3 id="vend-g-host-objektumok">Vend√©g (host) objektumok</h3>
<p>A <code>delete</code> oper√°tor m≈±k√∂d√©se megj√≥solhatatlan a vend√©g objektumokra. A specifik√°ci√≥
szerint ezek az objektumok sz√ºks√©g szerint b√°rmilyen viselked√©st implement√°lhatnak.</p>
<p>(A ford.: Vend√©g objektumok azok az objektumok, amelyek nincsenek konkr√©tan
meghat√°rozva az ES aktu√°lis verzi√≥j√∫ specifik√°ci√≥j√°ban, pl. a window)</p>
<h3 id="-sszegz-sk-pp">√ñsszegz√©sk√©pp</h3>
<p>A <code>delete</code> m≈±k√∂d√©se helyenk√©nt megj√≥solhatatlan, √≠gy biztons√°ggal csak olyan
objektumok mez≈ëin haszn√°lhatjuk, amelyeket expliciten mi √°ll√≠tottunk be.</p>
</div></article></section><section id="other"><!-- Introduction--><header id="other.intro"><h1>Egy√©b</h1></header><!-- Articles--><article id="other.timeouts"><h2>A var√°zslatos <code>setTimeout</code> √©s <code>setInterval</code></h2><div><p>Mivel a JavaScript aszinkron, a <code>setTimeout</code> √©s <code>setInterval</code> haszn√°lat√°val
lehets√©ges k√©sleltetni a k√≥dok lefut√°si idej√©t.</p>
<aside>
<p><strong>Megjegyz√©s:</strong> A timeout f√ºggv√©nyek <strong>nem</strong> r√©szei az ECMAScript Standardnek.
Mivel a <a href="http://en.wikipedia.org/wiki/Document_Object_Model" title="Document Object Model">DOM</a> r√©szek√©nt lettek implement√°lva.</p>
</aside>
<pre><code>function foo() {}
var id = setTimeout(foo, 1000); // Egy sz√°mmal (&gt; 0) t√©r vissza</code></pre>
<p>Amikor a <code>setTimeout</code> f√ºggv√©nyt megh√≠vjuk, v√°laszul egy timeout ID-t kapunk,
valamint be lesz √ºtemezve a <code>foo</code> f√ºggv√©nyh√≠v√°s, hogy <strong>k√∂r√ºlbel√ºl</strong> 1000 miliszekundum m√∫lva fusson le a j√∂v≈ëben. A <code>foo</code> <strong>egyszer</strong> lesz v√©grehajtva.</p>
<p>Az aktu√°lis JavaScript motor id≈ëz√≠t√©s√©t≈ël f√ºgg≈ëen, √©s annak figyelembe v√©tel√©vel,
hogy a JavaScript mindig egysz√°l√∫, teh√°t a megel≈ëz≈ë k√≥dok blokkolhatj√°k a sz√°lat,
<strong>soha</strong> nem lehet biztons√°gosan meghat√°rozni hogy val√≥ban a k√©rt id≈ëz√≠t√©ssel 
fog lefutni a k√≥d amit megadtunk a <code>setTimeout</code>ban. Erre semmilyen biztos√≠t√©k nincs.</p>
<p>Az els≈ë helyen bepasszolt f√ºggv√©ny a <em>glob√°lis objektum</em> √°ltal lesz megh√≠vva, ami
azt jelenti hogy a <a href="#function.this"><code>this</code></a> a f√ºggv√©nyen bel√ºl a glob√°lis objektumra
utal.</p>
<pre><code>function Foo() {
    this.value = 42;
    this.method = function() {
        // a this egy glob√°lis objektumra utal, nem a Foo-ra
        console.log(this.value); // undefined-ot logol ki
    };
    setTimeout(this.method, 500);
}
new Foo();</code></pre>
<aside>
<p><strong>Note:</strong> Mivel a <code>setTimeout</code> egy <strong>f√ºggv√©ny objektumot</strong> v√°r els≈ë param√©terek√©nt
egy gyakori hiba a <code>setTimeout(foo(), 1000)</code> m√≥don val√≥ haszn√°lata, amely a 
<code>foo</code> <strong>visszat√©r√©si √©rt√©k√©t</strong> fogja haszn√°lni √©s <strong>nem</strong> a <code>foo</code>t mint f√ºggv√©nyt. 
Ez a legt√∂bb esetben egy √©szrev√©tlen hib√°t okoz, mivel a f√ºggv√©ny <code>undefined</code>-t
t√©r√≠t vissza amire a <code>setTimeout</code> <strong>nem</strong> fog hib√°t dobni.</p>
</aside>
<h3 id="h-v-shalmoz-s-a-setinterval-al">H√≠v√°shalmoz√°s a <code>setInterval</code>al</h3>
<p>M√≠g a <code>setTimeout</code> csak egyszer futtatja le a megadott f√ºggv√©nyt, a <code>setInterval</code> -
ahogy a neve is mutatja - <strong>minden</strong> <code>X</code> miliszekundumban v√©grehajtja a 
neki √°tadott k√≥dot, haszn√°lata pedig er≈ësen ker√ºlend≈ë.</p>
<p>Nagy h√°tul√ºt≈ëje, hogy m√©g akkor is √ºtemezi az √∫jabb √©s √∫jabb
h√≠v√°sokat, hogyha az aktu√°lisan futattot k√≥d a megadott id≈ëintervallumon
fel√ºl blokkolja a tov√°bbi k√≥d futtat√°st. Ez, hogyha megfelel≈ëen r√∂vid
intervallumokat √°ll√≠tunk be, felhalmozza a f√ºggv√©nyh√≠v√°sokat a call stacken.</p>
<pre><code>function foo(){
    // k√≥d ami 1 m√°sodpercig feltartja a futtat√°st
}
setInterval(foo, 100);</code></pre>
<p>A fenti k√≥dban amikor a <code>foo</code> megh√≠v√≥dik, 1 m√°sodpercig feltartja a tov√°bbi futtat√°st.</p>
<p>A <code>setInterval</code> persze √ºtemezni fogja a j√∂v≈ëbeli <code>foo</code> h√≠v√°sokat tov√°bbra is, am√≠g
blokkol√≥dik a futtat√°s. √çgy <strong>t√≠z</strong> tov√°bbi h√≠v√°s fog v√°rakozni, miut√°n a <code>foo</code>
futtat√°sa el≈ësz√∂r v√©gzett.</p>
<h3 id="hogyan-b-njunk-el-a-blokkol-ssal">Hogyan B√°njunk El a Blokkol√°ssal</h3>
<p>A legk√∂nnyebb √©s kontroll√°lhat√≥bb megold√°snak az bizonyul, ha a <code>setTimeout</code>
f√ºggv√©nyt a r√∂gt√∂n a foo-n bel√ºl haszn√°ljuk.</p>
<pre><code>function foo(){
    // 1 m√°sodpercig blokkol√≥ k√≥d
    setTimeout(foo, 100);
}
foo();</code></pre>
<p>Ez nem csak egys√©gbe z√°rja a <code>setTimeout</code> h√≠v√°st, de megg√°tolja a felesleges h√≠v√°sok
felhalmoz√°s√°t, √©s t√∂bb ir√°ny√≠t√°st ad a kez√ºnkbe. A <code>foo</code> √≠gy mag√°t√≥l el tudja
d√∂nteni, hogy akarja-e √∫jra futtatni √∂nmag√°t vagy sem.</p>
<h3 id="timeout-tisztogat-s-k-zzel">Timeout Tisztogat√°s K√©zzel</h3>
<p>A <code>clearTimeout</code> vagy <code>clearInterval</code> h√≠v√°ssal tudjuk a timeoutjainkat 
megsz√ºntetni, term√©szetesen att√≥l f√ºgg, hogy melyiket haszn√°ljuk,
hogy melyik <code>set</code> f√ºggv√©nnyel ind√≠tottuk √∫tj√°ra a timeoutunkat.</p>
<pre><code>var id = setTimeout(foo, 1000);
clearTimeout(id);</code></pre>
<h3 id="az-sszes-timeout-megsz-ntet-se">Az √ñsszes Timeout Megsz√ºntet√©se</h3>
<p>Mivel nincsen be√©p√≠tett megold√°s az √∂sszes timeout √©s/vagy interval
h√≠v√°s t√∂rl√©s√©re, ez√©rt bruteforce m√≥dszerekhez kell folyamodjunk.</p>
<pre><code>// az &quot;√∂sszes&quot; timeout kit√∂rl√©se
for(var i = 1; i &lt; 1000; i++) {
    clearTimeout(i);
}</code></pre>
<p>Persze ez csak v√©letlenszer≈± l√∂v√∂ld√∂z√©s, semmi sem garant√°lja, hogy a fenti 
m√≥dszerrel nem marad timeout a rendszerben (A ford.: p√©ld√°ul az ezredik timeout vagy
afelett). Sz√≥val egy m√°sik m√≥dszer ennek megold√°s√°ra, hogy felt√©telezz√ºk hogy
minden <code>setTimeout</code> h√≠v√°ssal az azonos√≠t√≥k sz√°ma egyel n√∂vekszik.</p>
<pre><code>// az &quot;√∂sszes&quot; timeout ki√≠rt√°sa
var legnagyobbTimeoutId = window.setTimeout(function(){}, 1),
i;
for(i = 1; i &lt;= legnagyobbTimeoutId; i++) {
    clearTimeout(i);
}</code></pre>
<p>Hab√°r ez a megold√°s minden b√∂ng√©sz≈ëben megy (egyel≈ëre), ez az azonos√≠t√≥kr√≥l sz√ºletett mond√°s nincs specifik√°ci√≥ban r√∂gz√≠tve, √©s ennek megfelel≈ëen v√°ltozhat. 
Az aj√°nlott m√≥dszer tov√°bbra is az, hogy k√∂vess√ºk nyomon az √∂sszes timeout azonos√≠t√≥t, amit gener√°ltunk, √©s √≠gy ki is tudjuk ≈ëket rendesen t√∂r√∂lni.</p>
<h3 id="-eval-a-sz-nfalak-m-g-tt"><code>eval</code> A Sz√≠nfalak M√∂g√∂tt</h3>
<p>Hab√°r a <code>setTimeout</code> √©s a <code>setInterval</code> (k√≥d) stringet is tud els≈ë param√©terek√©nt
fogdani, ezt a fajta form√°j√°t haszn√°lni kimondottan <strong>tilos</strong>, mivel a f√ºgg√∂ny
m√∂g√∂tt ≈ë is csak <code>eval</code>t haszn√°l.</p>
<aside>
<p><strong>Megjegyz√©s:</strong> Mivel az ECMAScript Standard nem specifik√°lja a timeout
f√ºggv√©nyek m≈±k√∂d√©s√©t, az elt√©r≈ë JavaScript implement√°ci√≥kban elt√©r≈ë m√≥don
m≈±k√∂dhetnek. P√©ld√°ul a Microsoft JScript-je a <code>Function</code> konstruktort haszn√°lja
az <code>eval</code> helyett.</p>
</aside>
<pre><code>function foo() {
    // meg lesz h√≠vva
}

function bar() {
    function foo() {
        // soha nem h√≠v√≥dik meg
    }
    setTimeout(&#39;foo()&#39;, 1000);
}
bar();</code></pre>
<p>Mivel az <code>eval</code>t nem <a href="#core.eval">direkt</a> m√≥don h√≠vjuk meg a fenti esetben,
a <code>setTimeout</code>nak passzolt string a <em>glob√°lis hat√≥k√∂rben</em> fog lefutni; √≠gy
a lok√°lis <code>foo</code> f√ºggv√©nyt sosem haszn√°ljuk a <code>bar</code> hat√≥k√∂r√©b≈ël.</p>
<p>Tov√°bb√° <strong>nem</strong> aj√°nlott argumentumokat √°tadni annak a f√ºggv√©nynek amelyik
a timeout f√ºggv√©nyek √°ltal meg lesz h√≠vva a k√©s≈ëbbiekben.</p>
<pre><code>function foo(a, b, c) {}

// SOHA ne haszn√°ld √≠gy!
setTimeout(&#39;foo(1, 2, 3)&#39;, 1000)

// Ehelyett csomagoljuk n√©vtelen f√ºggv√©nybe
setTimeout(function() {
    foo(1, 2, 3);
}, 1000)</code></pre>
<aside>
<p><strong>Megjegyz√©s:</strong> Hab√°r lehets√©ges a <code>setTimeout(foo, 1000, 1, 2, 3)</code> szintaxist
haszn√°lni, m√©gsem aj√°nlott, mivel <a href="#function.this">met√≥dusok</a>  haszn√°latakor
√©szrevehetetlen hib√°khoz vezethet.</p>
</aside>
<h3 id="-sszegz-sk-pp">√ñsszegz√©sk√©pp</h3>
<p><strong>Soha</strong> ne haszn√°ljunk stringeket a <code>setTimeout</code> vagy <code>setInterval</code> els≈ë
param√©tereik√©nt. Ha argumentumokat kell √°tadni a megh√≠vand√≥ f√ºggv√©nynek, az 
egy√©rtelm≈±en <strong>rossz</strong> k√≥dra utal. Ebben az esetben a f√ºggv√©nyh√≠v√°s 
lebonyol√≠t√°s√°hoz egy <em>anonim</em> f√ºggv√©ny haszn√°lata aj√°nlott.</p>
<p>Tov√°bb√°, mivel az √ºtemez≈ë k√≥dja nem blokkol√≥dik a JavaScript fut√°s √°ltal, a 
<code>setInterval</code> haszn√°lata √∫gy √°ltal√°ban ker√ºlend≈ë.</p>
</div></article></section><!-- Footer--><footer><p>Copyright &copy;. Built with
|<a href="http://nodejs.org/"> Node.js</a> using a<a href="https://github.com/visionmedia/jade/"> jade</a> template.</p></footer><script src="//ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script><script src="../javascript/prettify.js"></script><script src="../javascript/garden.js"></script></body></html>